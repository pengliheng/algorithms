declare module ReactVapor {
	class SlideY extends React.Component<TransitionProps, {}> {
	    componentDidMount(): void;
	    componentWillUpdate(): void;
	    componentDidUpdate(): void;
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	interface ISvgProps extends React.HTMLProps<Svg> {
	    svgClass?: string;
	    svgName: string;
	}
	class Svg extends React.Component<ISvgProps, any> {
	    static defaultProps;
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	interface IOverlayTriggerProps {
	    animation?: any;
	    defaultOverlayShown?: boolean;
	    delay?: number;
	    delayHide?: number;
	    delayShow?: number;
	    onEnter?: (...args: any[]) => void;
	    onEntered?: (...args: any[]) => void;
	    onEntering?: (...args: any[]) => void;
	    onExit?: (...args: any[]) => void;
	    onExited?: (...args: any[]) => void;
	    onExiting?: (...args: any[]) => void;
	    onClick?: (...args: any[]) => void;
	    placement?: string;
	    container?: string;
	    rootClose?: boolean;
	    trigger?: string | string[];
	}
	interface ITooltipProps extends IOverlayTriggerProps, React.ClassAttributes<Tooltip> {
	    title: string;
	    className?: string;
	    arrowOffsetLeft?: number | string;
	    arrowOffsetTop?: number | string;
	    bsStyle?: string;
	    placement?: string;
	    positionLeft?: number;
	    positionTop?: number;
	    footer?: string;
	    noSpanWrapper?: boolean;
	}
	class Tooltip extends React.Component<ITooltipProps, {}> {
	    static defaultProps;
	    render(): any;
	}

}
declare module ReactVapor {
	interface IConfirmButtonLabel {
	    cancel: string;
	    confirm: string;
	}
	interface IConfirmData {
	    confirmType: string;
	    buttonLabels?: IConfirmButtonLabel;
	}
	interface IBaseActionOptions {
	    enabled: boolean;
	    name?: string;
	    link?: string;
	    target?: string;
	    primary?: boolean;
	    tooltip?: string;
	    tooltipPlacement?: string;
	    hideDisabled?: boolean;
	    onClick?: () => void;
	}
	interface IActionOptions extends IBaseActionOptions {
	    icon?: string;
	    iconClass?: string;
	    id?: string;
	    trigger?: () => void;
	    unrepeatable?: boolean;
	    callOnDoubleClick?: boolean;
	    requiresConfirmation?: IConfirmData;
	    separator?: boolean;
	    grouped?: boolean;
	    subActions?: IActionOptions[];
	    hidden?: boolean;
	}
	interface IBasicActionProps {
	    action: IActionOptions;
	    simple?: boolean;
	}
	interface IActionProps extends React.ClassAttributes<Action>, IBasicActionProps {
	}
	class Action extends React.Component<IActionProps, any> {
	    static defaultProps;
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	/// <reference types="jquery" />
	type IDispatch = (action: IReduxAction<any> | IThunkAction) => void;
	type IThunkAction = (dispatch: IDispatch, getState?: () => any) => void;
	class ReduxUtils {
	    static mergeProps(stateProps: any, dispatchProps: any, ownProps: any): any;
	}
	const CommonActions: {
	    clearState: string;
	};
	const clearState: () => Redux.Action;
	function ReduxConnect(mapStateToProps?: any, mapDispatchToProps?: any, mergeProps?: any, options?: any): (target: any) => any;
	interface BasePayload {
	    id: string;
	}
	interface IReduxAction<T = {}> extends Redux.Action {
	    type: string;
	    payload?: T;
	}
	interface IReduxProps {
	    dispatch?: (action: IReduxAction<any> | JQueryDeferred<any> | JQueryXHR | ((dispatch: Redux.Dispatch<any>) => void)) => void;
	}
	interface IReduxStatePossibleProps {
	    withReduxState?: boolean;
	}

}
declare module ReactVapor {
	interface ILinkSvgProps extends React.ClassAttributes<LinkSvg> {
	    url?: string;
	    target?: string;
	    linkClasses?: string[];
	    svg?: ISvgProps;
	    tooltip?: ITooltipProps;
	}
	class LinkSvg extends React.Component<ILinkSvgProps, {}> {
	    static defaultProps;
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	const DisplayClass: {
	    BLOCK: string;
	    INLINE: string;
	    INLINE_BLOCK: string;
	    HIDDEN: string;
	    TABLE: string;
	    TABLE_CELL: string;
	};
	type ComponentContent = (new () => React.Component) | string | ((props?: any) => JSX.Element);
	const getBasicDocumentLink: (url: string, title?: string) => ILinkSvgProps;

}
declare module ReactVapor {
	interface IContentProps {
	    content: ComponentContent;
	    componentProps?: {
	        [key: string]: any;
	    };
	    classes?: string[];
	    tag?: string;
	}
	class Content extends React.Component<IContentProps, {}> {
	    static defaultProps;
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	interface IItemFilterProps extends React.ClassAttributes<ItemFilter> {
	    label: string;
	    item: string;
	    itemTooltipProps?: ITooltipProps;
	    onClear: () => void;
	    crop?: number;
	}
	const ELLIPSIS: string;
	class ItemFilter extends React.Component<IItemFilterProps, any> {
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	interface ILinkActionProps extends React.ClassAttributes<LinkAction>, IBasicActionProps {
	}
	class LinkAction extends React.Component<ILinkActionProps> {
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	interface IUserChoice {
	    description?: string;
	    cancel?: string;
	    choices?: {
	        [key: string]: string;
	    };
	    icon?: string;
	}
	interface IInlinePromptOptions {
	    onClick: () => void;
	    userChoice: IUserChoice;
	    isOpened?: boolean;
	    className?: string;
	}
	interface IInlinePromptOwnProps extends React.ClassAttributes<InlinePrompt> {
	    id?: string;
	    options: IInlinePromptOptions;
	}
	interface IInlinePromptViewDispatchProps {
	    onCancel?: () => void;
	}
	interface IInlinePromptProps extends IInlinePromptOwnProps, IInlinePromptViewDispatchProps {
	}
	class InlinePrompt extends React.Component<IInlinePromptProps, any> {
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	interface ITriggerActionOwnProps extends React.ClassAttributes<TriggerAction>, IBasicActionProps {
	    confirmLabel?: string;
	    parentId?: string;
	}
	interface ITriggerActionDispatchProps {
	    onTriggerConfirm?: (onClick: () => void, userChoice: IUserChoice, className: string) => void;
	    onConfirm?: () => void;
	    onCloseDropdown?: () => void;
	}
	interface ITriggerActionProps extends ITriggerActionOwnProps, ITriggerActionDispatchProps {
	}
	const CONFIRM_LABEL: string;
	class TriggerAction extends React.Component<ITriggerActionProps, any> {
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	const LoadingActions: {
	    add: string;
	    remove: string;
	    turnOn: string;
	    turnOff: string;
	};
	interface ILoadingActionPayload {
	    ids: string[];
	}
	const addLoading: (id: string) => IReduxAction<ILoadingActionPayload>;
	const removeLoading: (id: string) => IReduxAction<ILoadingActionPayload>;
	const turnOnLoading: (ids: string[]) => IReduxAction<ILoadingActionPayload>;
	const turnOffLoading: (ids: string[]) => IReduxAction<ILoadingActionPayload>;

}
declare module ReactVapor {
	interface IActionBarPayload {
	    id: string;
	    yPosition?: number;
	}
	interface IChangeActionBarActionsPayload extends IActionBarPayload {
	    actions: IActionOptions[];
	}
	const ActionBarActions: {
	    add: string;
	    remove: string;
	    addActions: string;
	};
	const addActionBar: (id: string) => IReduxAction<IActionBarPayload>;
	const removeActionBar: (id: string) => IReduxAction<IActionBarPayload>;
	const addActionsToActionBar: (id: string, actions: IActionOptions[]) => IReduxAction<IChangeActionBarActionsPayload>;

}
declare module ReactVapor {
	interface IActionBarState {
	    id: string;
	    actions: IActionOptions[];
	    tableYPosition: number;
	    isLoading?: boolean;
	}
	const actionBarInitialState: IActionBarState;
	const actionBarsInitialState: IActionBarState[];
	const actionBarReducer: (state: IActionBarState, action: IReduxAction<IReduxActionsPayload>) => IActionBarState;
	const actionBarsReducer: (state: IActionBarState[], action: IReduxAction<IReduxActionsPayload>) => IActionBarState[];

}
declare module ReactVapor {
	const ItemFilterActions: {
	    add: string;
	    filter: string;
	    remove: string;
	};
	interface IItemFilterActionPayload {
	    id: string;
	}
	interface IItemFilteringActionPayload extends IItemFilterActionPayload {
	    item: string;
	}
	const addItemFilter: (id: string) => IReduxAction<IItemFilterActionPayload>;
	const filterItems: (id: string, item: string) => IReduxAction<IItemFilteringActionPayload>;
	const removeItemFilter: (id: string) => IReduxAction<IItemFilterActionPayload>;

}
declare module ReactVapor {
	interface IItemFilterState {
	    id: string;
	    item: string;
	}
	const itemFilterOriginalState: IItemFilterState;
	const itemFiltersOriginalState: IItemFilterState[];
	const itemFilterReducer: (state: IItemFilterState, action: IReduxAction<IReduxActionsPayload>) => IItemFilterState;
	const itemFiltersReducer: (state: IItemFilterState[], action: IReduxAction<IReduxActionsPayload>) => IItemFilterState[];

}
declare module ReactVapor {
	interface PartialStringMatchProps {
	    wholeString: string;
	    partialMatch?: string;
	    caseInsensitive?: boolean;
	}
	class PartialStringMatch extends React.Component<PartialStringMatchProps> {
	    static defaultProps;
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	interface IItemBoxProps {
	    value: string;
	    displayValue?: string;
	    highlight?: string;
	    selected?: boolean;
	    active?: boolean;
	    hidden?: boolean;
	    disabled?: boolean;
	    divider?: boolean;
	    tooltip?: ITooltipProps;
	    classes?: string[];
	    prepend?: IContentProps;
	    append?: IContentProps;
	    onOptionClick?: (option: IItemBoxProps) => void;
	}
	class ItemBox extends React.Component<IItemBoxProps, any> {
	    static defaultProps;
	    componentDidUpdate(prevProps: IItemBoxProps, prevState: IItemBoxProps): void;
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	const ListBoxActions: {
	    add: string;
	    remove: string;
	    select: string;
	    unselect: string;
	    reorder: string;
	    setActive: string;
	    clear: string;
	};
	interface IListBoxPayload {
	    id: string;
	    multi?: boolean;
	    value?: string;
	    values?: string[];
	    items?: IItemBoxProps[];
	    diff?: number;
	}
	const addListBox: (id: string, items: IItemBoxProps[]) => IReduxAction<IListBoxPayload>;
	const removeListBox: (id: string) => IReduxAction<IListBoxPayload>;
	const selectListBoxOption: (id: string, multi: boolean, value: string) => IReduxAction<IListBoxPayload>;
	const unselectListBoxOption: (id: string, value: string) => IReduxAction<IListBoxPayload>;
	const reorderListBoxOption: (id: string, values: string[]) => IReduxAction<IListBoxPayload>;
	const setActiveListBoxOption: (id: string, diff: number) => IReduxAction<IListBoxPayload>;
	const clearListBoxOption: (id: string) => IReduxAction<IListBoxPayload>;

}
declare module ReactVapor {
	const AutocompleteActions: {
	    add: string;
	    remove: string;
	    toggle: string;
	    setValue: string;
	    setActive: string;
	};
	interface IAutocompletePayload {
	    id: string;
	    open?: boolean;
	    value?: string;
	    diff?: number;
	}
	const addAutocomplete: (id: string) => IReduxAction<IAutocompletePayload>;
	const removeAutocomplete: (id: string) => IReduxAction<IAutocompletePayload>;
	const toggleAutocomplete: (id: string, open?: boolean) => IReduxAction<IAutocompletePayload>;
	const setAutocompleteValue: (id: string, value: string, open: boolean) => IReduxAction<IAutocompletePayload>;
	const setAutocompleteActive: (id: string, diff: number) => IReduxAction<IAutocompletePayload>;

}
declare module ReactVapor {
	interface IAutocompleteState {
	    id: string;
	    open: boolean;
	    value: string;
	    active: number;
	}
	const autocompleteInitialState: IAutocompleteState;
	const autocompleteCompositeInitialState: IAutocompleteState[];
	const autocompleteReducer: (state: IAutocompleteState, action: IReduxAction<IAutocompletePayload>) => IAutocompleteState;
	const autocompletesReducer: (state: IAutocompleteState[], action: IReduxAction<IAutocompletePayload>) => IAutocompleteState[];

}
declare module ReactVapor {
	interface ICheckboxActionPayload {
	    id: string;
	    checked?: boolean;
	    disabled?: boolean;
	}
	const CheckboxActions: {
	    toggle: string;
	    add: string;
	    remove: string;
	};
	const toggleCheckbox: (id: string, checked?: boolean) => IReduxAction<ICheckboxActionPayload>;
	const addCheckbox: (id: string, checked: boolean) => IReduxAction<ICheckboxActionPayload>;
	const removeCheckbox: (id: string) => IReduxAction<ICheckboxActionPayload>;

}
declare module ReactVapor {
	interface ICheckboxState {
	    id: string;
	    checked: boolean;
	    disabled: boolean;
	}
	const checkboxInitialState: ICheckboxState;
	const checkboxesInitialState: ICheckboxState[];
	const checkboxReducer: (state: ICheckboxState, action: IReduxAction<ICheckboxActionPayload>) => ICheckboxState;
	const checkboxesReducer: (state: ICheckboxState[], action: IReduxAction<ICheckboxActionPayload>) => ICheckboxState[];

}
declare module ReactVapor {
	interface IGroupableCheckboxActionPayload {
	    id: string;
	    checked?: boolean;
	    isGroupable?: boolean;
	    isParent?: boolean;
	    parentId?: string;
	    disabled?: boolean;
	    disabledAll?: boolean;
	}
	const GroupableCheckboxActions: {
	    toggleGroup: string;
	    addGroup: string;
	    removeGroup: string;
	    disabledGroup: string;
	    disabledAllGroup: string;
	};
	const toggleGroupedCheckbox: (id: string, parentId: string, isParent?: boolean) => IReduxAction<IGroupableCheckboxActionPayload>;
	const addGroupedCheckbox: (id: string, checked: boolean, disabled: boolean, parentId: string, isParent?: boolean) => IReduxAction<IGroupableCheckboxActionPayload>;
	const removeGroupedCheckbox: (id: string, parentId: string, isParent?: boolean) => IReduxAction<IGroupableCheckboxActionPayload>;
	const toggleDisabledGroupedCheckbox: (id: string, parentId: string, isParent?: boolean) => IReduxAction<IGroupableCheckboxActionPayload>;
	const toggleDisabledAllGroupedCheckbox: (id: string, parentId?: string, disabled?: boolean) => IReduxAction<IGroupableCheckboxActionPayload>;

}
declare module ReactVapor {
	const calculateTotalCheckboxesChecked: (checkboxes: ICheckboxState[]) => number;
	const addParentCheckbox: (state: IGroupableCheckboxesState, action: IReduxAction<IGroupableCheckboxActionPayload>) => IGroupableCheckboxesState;
	const addChildCheckbox: (state: IGroupableCheckboxesState, action: IReduxAction<IGroupableCheckboxActionPayload>) => IGroupableCheckboxesState;
	const removeParentCheckbox: (state: IGroupableCheckboxesState[], action: IReduxAction<IGroupableCheckboxActionPayload>) => IGroupableCheckboxesState[];
	const removeChildCheckbox: (state: IGroupableCheckboxesState, action: IReduxAction<IGroupableCheckboxActionPayload>) => IGroupableCheckboxesState;
	const toggleChildCheckbox: (state: IGroupableCheckboxesState, action: IReduxAction<IGroupableCheckboxActionPayload>) => {
	    parent: {
	        id: string;
	        checked: boolean;
	        disabled: boolean;
	    };
	    nbChecked: number;
	    checkboxes: ICheckboxState[];
	    total: number;
	    parentId?: string;
	};
	const toggleParentCheckbox: (state: IGroupableCheckboxesState, action: IReduxAction<IGroupableCheckboxActionPayload>) => {
	    parent: {
	        id: string;
	        checked: boolean;
	        disabled: boolean;
	    };
	    checkboxes: ICheckboxState[];
	    nbChecked: number;
	    total: number;
	    parentId?: string;
	};
	const disabledParentCheckbox: (state: IGroupableCheckboxesState, action: IReduxAction<IGroupableCheckboxActionPayload>) => {
	    parent: {
	        id: string;
	        disabled: boolean;
	        checked: boolean;
	    };
	    total: number;
	    nbChecked: number;
	    parentId?: string;
	    checkboxes: ICheckboxState[];
	};
	const disabledChildCheckbox: (state: IGroupableCheckboxesState, action: IReduxAction<IGroupableCheckboxActionPayload>) => {
	    checkboxes: ICheckboxState[];
	    total: number;
	    nbChecked: number;
	    parentId?: string;
	    parent?: ICheckboxState;
	};
	const disabledAllCheckbox: (state: IGroupableCheckboxesState, action: IReduxAction<IGroupableCheckboxActionPayload>) => {
	    parent: {
	        id: string;
	        disabled: boolean;
	        checked: boolean;
	    };
	    checkboxes: {
	        disabled: boolean;
	        id: string;
	        checked: boolean;
	    }[];
	    total: number;
	    nbChecked: number;
	    parentId?: string;
	};

}
declare module ReactVapor {
	interface IGroupableCheckboxesState {
	    total: number;
	    nbChecked: number;
	    parentId?: string;
	    parent?: ICheckboxState;
	    checkboxes: ICheckboxState[];
	}
	const groupableCheckboxInitialState: IGroupableCheckboxesState;
	const groupableCheckboxesInitialState: IGroupableCheckboxesState[];
	const groupableCheckboxReducer: (state: IGroupableCheckboxesState, action: IReduxAction<IGroupableCheckboxActionPayload>) => IGroupableCheckboxesState;
	const groupableCheckboxesReducer: (state: IGroupableCheckboxesState[], action: IReduxAction<IGroupableCheckboxActionPayload>) => IGroupableCheckboxesState[];

}
declare module ReactVapor {
	const CollapsibleActions: {
	    add: string;
	    remove: string;
	    setExpanded: string;
	};
	interface CollapsiblePayload extends BasePayload {
	    expanded?: boolean;
	}
	interface ILoadingActionPayload extends CollapsiblePayload {
	}
	const addCollapsible: (id: string, expanded: boolean) => IReduxAction<CollapsiblePayload>;
	const addCollapsibleContainer: (id: string, expanded: boolean) => IReduxAction<CollapsiblePayload>;
	const removeCollapsible: (id: string) => IReduxAction<CollapsiblePayload>;
	const removeCollapsibleContainer: (id: string) => IReduxAction<CollapsiblePayload>;
	const setCollapsibleExpanded: (id: string, expanded: boolean) => IReduxAction<CollapsiblePayload>;
	const setExpandedCollapsibleContainer: (id: string, expanded: boolean) => IReduxAction<CollapsiblePayload>;

}
declare module ReactVapor {
	interface CollapsibleState {
	    id: string;
	    expanded: boolean;
	}
	interface ICollapsibleContainerState extends CollapsibleState {
	}
	const collapsibleInitialState: CollapsibleState;
	const collapsiblesInitialState: CollapsibleState[];
	const collapsiblesReducer: (state: CollapsibleState[], action: IReduxAction<CollapsiblePayload>) => CollapsibleState[];
	const collapsibleContainersReducer: (state: CollapsibleState[], action: IReduxAction<CollapsiblePayload>) => CollapsibleState[];

}
declare module ReactVapor {
	interface IDay {
	    number: number;
	    isCurrentMonth: boolean;
	    isToday: boolean;
	    date: Moment;
	    isSelected?: boolean;
	    isLowerLimit?: boolean;
	    isUpperLimit?: boolean;
	    color?: string;
	    isSelectable?: boolean;
	}
	interface ICalendarDayProps extends React.ClassAttributes<CalendarDay> {
	    day: IDay;
	    onClick: (value: Date) => void;
	    onSelectUnselectable: () => void;
	}
	class CalendarDay extends React.Component<ICalendarDayProps, {}> {
	    static DEFAULT_DATE_CLASS: string;
	    componentWillReceiveProps(nextProps: ICalendarDayProps): void;
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	interface IDateComponents {
	    year?: number;
	    month?: number;
	    date?: number;
	    hours?: number;
	    minutes?: number;
	    seconds?: number;
	    milliseconds?: number;
	}
	const SIMPLE_DATE_FORMAT: string;
	const LONG_DATE_FORMAT: string;
	const DATES_SEPARATOR: string;
	class DateUtils {
	    static currentDate: Date;
	    static currentMonth: number;
	    static currentYear: number;
	    static getPreviousYears(numberOfYears: number): string[];
	    static getNextYears(numberOfYears: number): string[];
	    static getMonthWeeks(firstDay: Date, startingDay: number): IDay[][];
	    static getDateWithTimeString(date: Date): string;
	    static getDateFromTimeString(date: string): Date;
	    static getValidDate(date: string, fromTime?: boolean): Date;
	    static getSimpleDate(date: Date): string;
	    static getDateFromSimpleDateString(date: string): Date;
	    static isDifferent(firstDate: moment.MomentInput, secondDate: moment.MomentInput, granularity?: moment.unitOfTime.StartOf): boolean;
	}

}
declare module ReactVapor {
	interface ISetToNowProps extends React.ClassAttributes<SetToNowButton> {
	    onClick: () => void;
	    tooltip?: string;
	}
	const SET_TO_NOW_DEFAULT_TOOLTIP: string;
	class SetToNowButton extends React.Component<ISetToNowProps, any> {
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	interface IDatePickerProps extends React.ClassAttributes<DatePicker> {
	    onBlur: (date: Date, isUpperLimit: boolean) => void;
	    onClick: (isUpperLimit: boolean) => void;
	    placeholder: string;
	    withTime?: boolean;
	    hasSetToNowButton?: boolean;
	    upperLimit?: boolean;
	    date?: Date;
	    setToNowTooltip?: string;
	    isSelecting?: string;
	    color?: string;
	}
	const DatePickerColors: {
	    blue: string;
	    green: string;
	    yellow: string;
	    red: string;
	    orange: string;
	};
	const DEFAULT_DATE_PICKER_COLOR: string;
	class DatePicker extends React.Component<IDatePickerProps, any> {
	    static defaultProps;
	    handleDocumentClick: (e: MouseEvent) => void;
	    componentDidMount(): void;
	    componentWillReceiveProps(nextProps: IDatePickerProps): void;
	    componentWillUnmount(): void;
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	type DatePickerDateRange = [Date, Date];

}
declare module ReactVapor {
	interface IRangeLimit {
	    weeks?: number;
	    days?: number;
	    hours?: number;
	    message?: string;
	}
	interface IDatesSelectionOwnProps extends React.ClassAttributes<DatesSelection> {
	    id?: string;
	    withTime?: boolean;
	    hasSetToNowButton?: boolean;
	    isRange?: boolean;
	    isClearable?: boolean;
	    rangeLimit?: IRangeLimit;
	    color?: string;
	    calendarId?: string;
	    defaultLowerLimit?: Date;
	    defaultUpperLimit?: Date;
	    lowerLimitPlaceholder?: string;
	    upperLimitPlaceholder?: string;
	    initiallyUnselected?: boolean;
	    initialDateRange?: DatePickerDateRange;
	}
	interface IDatesSelectionStateProps {
	    lowerLimit?: Date;
	    upperLimit?: Date;
	    inputLowerLimit?: Date;
	    inputUpperLimit?: Date;
	    quickOption?: string;
	    isSelecting?: string;
	}
	interface IDatesSelectionDispatchProps {
	    onRender?: () => void;
	    onDestroy?: () => void;
	    onClick?: (isUpperLimit: boolean) => void;
	    onBlur?: (date: Date, isUpperLimit: boolean, datePicker?: boolean) => void;
	}
	interface IDatesSelectionChildrenProps {
	    setToNowTooltip?: string;
	}
	interface IDatesSelectionProps extends IDatesSelectionOwnProps, IDatesSelectionStateProps, IDatesSelectionDispatchProps, IDatesSelectionChildrenProps {
	}
	const LOWER_LIMIT_PLACEHOLDER: string;
	const UPPER_LIMIT_PLACEHOLDER: string;
	class DatesSelection extends React.Component<IDatesSelectionProps, any> {
	    static defaultProps;
	    componentWillMount(): void;
	    componentWillUnmount(): void;
	    componentWillReceiveProps(nextProps: IDatesSelectionProps): void;
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	const DatePickerActions: {
	    add: string;
	    remove: string;
	    changeLowerLimit: string;
	    changeUpperLimit: string;
	    select: string;
	    reset: string;
	    apply: string;
	    clear: string;
	};
	interface IDatePickerPayload {
	    id: string;
	}
	interface IAddDatePickerPayload extends IDatePickerPayload {
	    color: string;
	    calendarId: string;
	    isRange: boolean;
	    rangeLimit?: IRangeLimit;
	    initiallyUnselected?: boolean;
	    isClearable?: boolean;
	    simple?: boolean;
	    initialDateRange?: DatePickerDateRange;
	}
	interface IChangeDatePickerPayload extends IDatePickerPayload {
	    date: Date;
	}
	interface ISelectDatePickerPayload extends IDatePickerPayload {
	    limit: string;
	}
	const DateLimits: {
	    lower: string;
	    upper: string;
	};
	const addDatePicker: (id: string, isRange: boolean, rangeLimit?: IRangeLimit, color?: string, calendarId?: string, initiallyUnselected?: boolean, isClearable?: boolean, simple?: boolean, initialDateRange?: [Date, Date]) => IReduxAction<IAddDatePickerPayload>;
	const removeDatePicker: (id: string) => IReduxAction<IDatePickerPayload>;
	const resetDatePickers: (id: string) => IReduxAction<IDatePickerPayload>;
	const applyDatePicker: (id: string) => IReduxAction<IDatePickerPayload>;
	const changeDatePickerLowerLimit: (id: string, date: Date) => IReduxAction<IChangeDatePickerPayload>;
	const changeDatePickerUpperLimit: (id: string, date: Date) => IReduxAction<IChangeDatePickerPayload>;
	const selectDate: (id: string, limit: string) => IReduxAction<ISelectDatePickerPayload>;
	const clearSelection: (id: string) => IReduxAction<IDatePickerPayload>;

}
declare module ReactVapor {
	interface IDatePickerState {
	    id: string;
	    calendarId: string;
	    color: string;
	    lowerLimit: Date;
	    upperLimit: Date;
	    inputLowerLimit: Date;
	    inputUpperLimit: Date;
	    rangeLimit?: IRangeLimit;
	    isRange: boolean;
	    isClearable: boolean;
	    selected: string;
	    appliedLowerLimit: Date;
	    appliedUpperLimit: Date;
	    simple: boolean;
	}
	const datePickerInitialState: IDatePickerState;
	const datePickersInitialState: IDatePickerState[];
	const datePickerReducer: (state: IDatePickerState, action: IReduxAction<any>) => IDatePickerState;
	const datePickersReducer: (state: IDatePickerState[], action: IReduxAction<IReduxActionsPayload>) => IDatePickerState[];

}
declare module ReactVapor {
	interface IDropdownActionPayload {
	    id: string;
	}
	const DropdownActions: {
	    add: string;
	    remove: string;
	    toggle: string;
	    close: string;
	};
	const addDropdown: (id: string) => IReduxAction<IDropdownActionPayload>;
	const removeDropdown: (id: string) => IReduxAction<IDropdownActionPayload>;
	const toggleDropdown: (id: string) => IReduxAction<IDropdownActionPayload>;
	const closeDropdown: (id: string) => IReduxAction<IDropdownActionPayload>;

}
declare module ReactVapor {
	interface IDropdownState {
	    id: string;
	    opened: boolean;
	}
	const dropdownInitialState: IDropdownState;
	const dropdownsInitialState: IDropdownState[];
	const dropdownReducer: (state: IDropdownState, action: IReduxAction<IReduxActionsPayload>) => IDropdownState;
	const dropdownsReducer: (state: IDropdownState[], action: IReduxAction<IReduxActionsPayload>) => IDropdownState[];

}
declare module ReactVapor {
	const convertUndefinedAndNullToEmptyString: (value: any) => any;
	const callIfDefined: <T>(callback: (...params: any[]) => T, ...args: any[]) => T;

}
declare module ReactVapor {
	const keyCode: {
	    backspace: number;
	    tab: number;
	    enter: number;
	    shift: number;
	    ctrl: number;
	    alt: number;
	    pause: number;
	    capsLock: number;
	    escape: number;
	    pageUp: number;
	    pageDown: number;
	    end: number;
	    home: number;
	    leftArrow: number;
	    upArrow: number;
	    rightArrow: number;
	    downArrow: number;
	    insert: number;
	    delete: number;
	};

}
declare module ReactVapor {
	interface IFilterBoxOwnProps extends React.ClassAttributes<FilterBox> {
	    id?: string;
	    containerClasses?: string[];
	    filterPlaceholder?: string;
	    onBlur?: () => void;
	    onKeyDown?: (e) => void;
	    onKeyUp?: (e) => void;
	    isAutoFocus?: boolean;
	    maxWidth?: number;
	    withTitleOnInput?: boolean;
	    truncate?: boolean;
	    onFilterCallback?: (id: string, filterText: string) => void;
	}
	interface IFilterBoxStateProps {
	    filterText?: string;
	}
	interface IFilterBoxDispatchProps {
	    onRender?: (id: string) => void;
	    onDestroy?: (id: string) => void;
	    onFilter?: (id: string, filterText: string) => void;
	}
	interface IFilterBoxProps extends IFilterBoxOwnProps, IFilterBoxStateProps, IFilterBoxDispatchProps {
	}
	const FILTER_PLACEHOLDER: string;
	class FilterBox extends React.Component<IFilterBoxProps, any> {
	    filterInput: HTMLInputElement;
	    constructor(props: IFilterBoxProps);
	    static defaultProps;
	    placeCursorAtEndOfInputValue(e): void;
	    componentWillMount(): void;
	    componentWillUnmount(): void;
	    componentWillReceiveProps(nextProps: IFilterBoxProps): void;
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	interface DropdownSearchInfiniteScrollOptionsProps {
	    onMouseEnter: () => void;
	    options: JSX.Element[];
	    ulElementRefFunction: (menu: HTMLElement) => void;
	    infiniteScroll: InfiniteScroll.InfiniteScrollProps;
	}
	class DropdownSearchInfiniteScrollOptions extends React.Component<DropdownSearchInfiniteScrollOptionsProps, {}> {
	    componentWillMount(): void;
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	interface IDropdownOption {
	    svg?: ISvgProps;
	    value: string;
	    displayValue?: string;
	    prefix?: string;
	    selected?: boolean;
	    custom?: boolean;
	    hidden?: boolean;
	    disabled?: boolean;
	    disabledTooltip?: ITooltipProps;
	    default?: boolean;
	    append?: string;
	}
	interface IDropdownSearchStateProps {
	    isOpened?: boolean;
	    filterText?: string;
	    options?: IDropdownOption[];
	    activeOption?: IDropdownOption;
	    setFocusOnDropdownButton?: boolean;
	}
	interface IDropdownSearchOwnProps extends React.ClassAttributes<DropdownSearch> {
	    id?: string;
	    modMenu?: boolean;
	    fixedPrepend?: string;
	    containerClasses?: string[];
	    defaultOptions?: IDropdownOption[];
	    defaultSelectedOption?: IDropdownOption;
	    filterPlaceholder?: string;
	    maxWidth?: number | string;
	    width?: number | string;
	    hasFilterSuggestionBoxWidthFixed?: boolean;
	    highlightThreshold?: number;
	    highlightAllFilterResult?: boolean;
	    noResultText?: string;
	    createOptionText?: string;
	    deselectAllTooltipText?: string;
	    isDisabled?: boolean;
	    onOptionClickCallBack?: (option: IDropdownOption) => void;
	    onMountCallBack?: () => void;
	    onClickCallBack?: () => void;
	    supportSingleCustomOption?: boolean;
	    searchThresold?: number;
	    infiniteScroll?: InfiniteScrollProps;
	    hasMoreItems?: () => boolean;
	    customFiltering?: (filterText: string) => void;
	}
	interface IDropdownSearchDispatchProps {
	    onMount?: () => void;
	    onDestroy?: () => void;
	    onToggleDropdown?: () => void;
	    onBlur?: (options: IDropdownOption[]) => void;
	    onFocus?: () => void;
	    onFilterTextChange?: (filterText: string) => void;
	    onOptionClick?: (option: IDropdownOption) => void;
	    onCustomOptionClick?: (displayValue: string) => void;
	    onKeyDownFilterBox?: (keyCode: number, activeOption?: IDropdownOption) => void;
	    onKeyDownDropdownButton?: (keyCode: number, activeOption?: IDropdownOption) => void;
	    onMouseEnterDropdown?: (activeOption?: IDropdownOption) => void;
	    onRemoveSelectedOption?: (value: string) => void;
	    onRemoveAllSelectedOptions?: () => void;
	    onClose?: () => void;
	    updateOptions?: (options: IDropdownOption[]) => void;
	}
	interface IDropdownSearchProps extends IDropdownSearchOwnProps, IDropdownSearchStateProps, IDropdownSearchDispatchProps {
	}
	class DropdownSearch extends React.Component<IDropdownSearchProps, {}> {
	    static defaultProps;
	    filterInput: HTMLDivElement;
	    ulElement: HTMLElement;
	    protected dropdownButton: HTMLElement;
	    componentDidUpdate(): void;
	    componentWillMount(): void;
	    componentWillUnmount(): void;
	    render(): JSX.Element;
	    protected getDropdownOptions(): JSX.Element[];
	    protected getSelectedOption(): IDropdownOption;
	    protected getSelectedOptions(): IDropdownOption[];
	    protected getDropdownOptionAppend(option?: IDropdownOption): JSX.Element;
	    protected getNoOptions(): JSX.Element[];
	    protected getSvg(option: IDropdownOption): JSX.Element;
	    protected getTextFiltered(text: string): Array<JSX.Element | string> | string;
	    protected getTextElement(subText: string, text: string, highlightIndexKey: number, className?: string): JSX.Element;
	    protected getMainInputPrepend(option: IDropdownOption): JSX.Element;
	    protected getDropdownPrepend(option: IDropdownOption): JSX.Element;
	    protected getMainInput(): JSX.Element;
	    protected isScrolledIntoView(el: Element): boolean;
	    protected getDisplayedOptions(): IDropdownOption[];
	    protected handleOnOptionClickOnKeyDown(e): void;
	    protected handleOnKeyDownFilterBox(e): void;
	    protected getClasses(): string;
	    protected getStyles(): {
	        width: string | number;
	    };
	}

}
declare module ReactVapor {
	function deepClone(object: any): any;

}
declare module ReactVapor {
	const getDropdownSearchSelectedOption: (id: string, dropdownSearchState?: IDropdownSearchState[]) => IDropdownOption;
	const isSelectingOption: (keyPressed: number, activeOption: IDropdownOption) => boolean;

}
declare module ReactVapor {
	interface IDefaultDropdownSearchPayload {
	    id: string;
	}
	interface IInputDrodownSearchPayload extends IDefaultDropdownSearchPayload {
	    keyCode?: number;
	    activeOption?: IDropdownOption;
	}
	interface IOptionsDropdownSearchPayload extends IDefaultDropdownSearchPayload, IInputDrodownSearchPayload {
	    dropdownOptions?: IDropdownOption[];
	    filterText?: string;
	    selectedOptions?: IDropdownOption[];
	    defaultSelectedOption?: IDropdownOption;
	    selectedOptionValue?: string;
	    addedSelectedOption?: IDropdownOption;
	    isOpened?: boolean;
	    supportSingleCustomOption?: boolean;
	    setFocusOnDropdown?: boolean;
	    selectAValue?: boolean;
	}
	const DropdownSearchActions: {
	    toggle: string;
	    open: string;
	    close: string;
	    add: string;
	    addMultiSelect: string;
	    addCustomSelectedOption: string;
	    remove: string;
	    update: string;
	    filter: string;
	    select: string;
	    active: string;
	    deselectOption: string;
	    deselectAllOptions: string;
	    multiSelect: string;
	    onKeyDownMultiselect: string;
	};
	const applyFilterDropdownSearch: (id: string, filterText: string) => IReduxAction<IOptionsDropdownSearchPayload>;
	const updateOptionsDropdownSearch: (id: string, dropdownOptions: IDropdownOption[], defaultSelectedOption?: IDropdownOption, selectAValue?: boolean) => IReduxAction<IOptionsDropdownSearchPayload>;
	const toggleDropdownSearch: (id: string) => IReduxAction<IDefaultDropdownSearchPayload>;
	const openDropdownSearch: (id: string) => IReduxAction<IDefaultDropdownSearchPayload>;
	const closeDropdownSearch: (id: string, dropdownOptions?: IDropdownOption[]) => IReduxAction<IOptionsDropdownSearchPayload>;
	const addDropdownSearch: (id: string, dropdownOptions: IDropdownOption[], defaultSelectedOption?: IDropdownOption, supportSingleCustomOption?: boolean) => IReduxAction<IOptionsDropdownSearchPayload>;
	const addMultiSelectDropdownSearch: (id: string, dropdownOptions: IDropdownOption[]) => IReduxAction<IOptionsDropdownSearchPayload>;
	const removeDropdownSearch: (id: string) => IReduxAction<IDefaultDropdownSearchPayload>;
	const selectOptionDropdownSearch: (id: string, addedSelectedOption: IDropdownOption, setFocusOnDropdown?: boolean) => IReduxAction<IOptionsDropdownSearchPayload>;
	const multiSelectOptionDropdownSearch: (id: string, addedSelectedOption: IDropdownOption) => IReduxAction<IOptionsDropdownSearchPayload>;
	const addCustomSelectedOption: (id: string, selectedOptionValue: string) => IReduxAction<IOptionsDropdownSearchPayload>;
	const deselectOptionDropdownSearch: (id: string, selectedOptionValue: string) => IReduxAction<IOptionsDropdownSearchPayload>;
	const deselectAllOptionsMultiselectDropdownSearch: (id: string) => IReduxAction<IOptionsDropdownSearchPayload>;
	const updateActiveOptionDropdownSearch: (id: string, keyCode: number, activeOption?: IDropdownOption) => IReduxAction<IInputDrodownSearchPayload>;
	const keyDownMultiselectDropdownSearch: (id: string, keyCode: number) => IReduxAction<IInputDrodownSearchPayload>;
	const selectOrSetNextActiveOption: (id: string, keyCode: number, activeOption?: IDropdownOption) => IReduxAction<IInputDrodownSearchPayload>;

}
declare module ReactVapor {
	const multiSelectDropdownSearchReducer: (state: IDropdownSearchState, action: IReduxAction<IOptionsDropdownSearchPayload>) => IDropdownSearchState;

}
declare module ReactVapor {
	interface IDropdownSearchState {
	    id: string;
	    isOpened?: boolean;
	    filterText?: string;
	    options?: IDropdownOption[];
	    selectedOption?: IDropdownOption;
	    activeOption?: IDropdownOption;
	    setFocusOnDropdownButton?: boolean;
	    defaultSelectedOptionValue?: string;
	    supportSingleCustomOption?: boolean;
	}
	const defaultSelectedOptionPlaceholder: IDropdownOption;
	const dropdownSearchInitialState: IDropdownSearchState;
	const dropdownsSearchInitialState: IDropdownSearchState[];
	const getNextIndexPosition: (array: any[], item: any, key: number) => number;
	const isNotCustomOption: (option: IDropdownOption, includeSelected?: boolean) => boolean;
	const removeCustomOptions: (options: IDropdownOption[], supportSingleCustomOption: boolean, includeSelected?: boolean) => any;
	const shouldHideOnFilter: (option: IDropdownOption, filterText: string) => boolean;
	const deselectOption: (options: IDropdownOption[], value: string) => IDropdownOption[];
	const deselectLastSelectedOption: (options: IDropdownOption[]) => IDropdownOption[];
	const deselectAllOptions: (options: IDropdownOption[], includeCustom?: boolean) => IDropdownOption[];
	const addUniqueSelectedOption: (options: IDropdownOption[], value: string, displayValue?: string) => IDropdownOption[];
	const getDisplayedOptions: (state: IDropdownSearchState) => IDropdownOption[];
	const getFilteredOptions: (state: IDropdownSearchState, filterText?: string) => IDropdownOption[];
	const selectSingleOption: (options: IDropdownOption[], selectedOption: IDropdownOption) => IDropdownOption[];
	const multiSelectOption: (options: IDropdownOption[], selectedOption: IDropdownOption) => IDropdownOption[];
	const updateOptions: (options: IDropdownOption[], selectAValue?: boolean, selectedOption?: IDropdownOption) => IDropdownOption[];
	const dropdownSearchReducer: (state: IDropdownSearchState, action: IReduxAction<IOptionsDropdownSearchPayload>) => IDropdownSearchState;
	const dropdownsSearchReducer: (state: IDropdownSearchState[], action: IReduxAction<IOptionsDropdownSearchPayload>) => IDropdownSearchState[];

}
declare module ReactVapor {
	const FilterActions: {
	    addFilter: string;
	    removeFilter: string;
	    filterThrough: string;
	};
	interface IFilterActionPayload {
	    id: string;
	}
	interface IChangeFilterActionPayload extends IFilterActionPayload {
	    filterText: string;
	}
	const addFilter: (id: string) => IReduxAction<IFilterActionPayload>;
	const removeFilter: (id: string) => IReduxAction<IFilterActionPayload>;
	const filterThrough: (id: string, filterText: string) => IReduxAction<IChangeFilterActionPayload>;

}
declare module ReactVapor {
	const debouncedFilterThrough: ((dispatch: IDispatch, id: string, filterText: string) => void) & _.Cancelable;
	const FilterBoxConnected: React.ComponentClass<IFilterBoxProps>;

}
declare module ReactVapor {
	interface IFacetMoreRowsOwnProps extends React.ClassAttributes<FacetMoreRows> {
	    facet: string;
	    facetRows: JSX.Element[];
	}
	interface IFacetMoreRowsStateProps extends IReduxStatePossibleProps {
	    isOpened?: boolean;
	    filterText?: string;
	}
	interface IFacetMoreRowsDispatchProps {
	    onOpen?: () => void;
	    onDocumentClick?: () => void;
	}
	interface IFacetMoreRowsChildrenProps {
	    filterPlaceholder?: string;
	}
	interface IFacetMoreRowsProps extends IFacetMoreRowsOwnProps, IFacetMoreRowsDispatchProps, IFacetMoreRowsStateProps, IFacetMoreRowsChildrenProps {
	}
	class FacetMoreRows extends React.Component<IFacetMoreRowsProps, any> {
	    componentWillMount(): void;
	    componentWillReceiveProps(nextProps: IFacetMoreRowsProps): void;
	    componentWillUnmount(): void;
	    componentDidUpdate(): void;
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	const SelectActions: {
	    add: string;
	    remove: string;
	    toggle: string;
	};
	interface ISelectPayload {
	    id: string;
	    open?: boolean;
	}
	const addSelect: (id: string) => IReduxAction<ISelectPayload>;
	const removeSelect: (id: string) => IReduxAction<ISelectPayload>;
	const toggleSelect: (id: string, open?: boolean) => IReduxAction<ISelectPayload>;

}
declare module ReactVapor {
	interface IFilterState {
	    id: string;
	    filterText: string;
	}
	const filterBoxInitialState: IFilterState;
	const filtersInitialState: IFilterState[];
	const filterBoxReducer: (state: IFilterState, action: IReduxAction<IReduxActionsPayload>) => IFilterState;
	const filterBoxesReducer: (state: IFilterState[], action: IReduxAction<IReduxActionsPayload>) => IFilterState[];

}
declare module ReactVapor {
	const FacetActions: {
	    addFacet: string;
	    removeFacet: string;
	    changeFacet: string;
	    emptyFacet: string;
	    emptyAllFacets: string;
	    toggleMoreFacetRows: string;
	    closeMoreFacetRows: string;
	};
	interface IFacetActionPayload {
	    facet: string;
	}
	interface IChangeFacetActionPayload extends IFacetActionPayload {
	    facetRow: IFacet;
	}
	const addFacet: (facet: string) => IReduxAction<IFacetActionPayload>;
	const removeFacet: (facet: string) => IReduxAction<IFacetActionPayload>;
	const changeFacet: (facet: string, facetRow: IFacet) => IReduxAction<IChangeFacetActionPayload>;
	const emptyFacet: (facet: string) => IReduxAction<IFacetActionPayload>;
	const emptyAllFacets: () => IReduxAction<IFacetActionPayload>;
	const toggleMoreFacetRows: (facet: string) => IReduxAction<IFacetActionPayload>;
	const closeMoreFacetRows: () => IReduxAction<IFacetActionPayload>;

}
declare module ReactVapor {
	interface IFacetState {
	    facet: string;
	    opened: boolean;
	    selected: IFacet[];
	}
	const facetInitialState: IFacetState;
	const facetsInitialState: IFacetState[];
	const facetReducer: (state: IFacetState, action: IReduxAction<IReduxActionsPayload>) => IFacetState;
	const facetsReducer: (state: IFacetState[], action: IReduxAction<IReduxActionsPayload>) => IFacetState[];

}
declare module ReactVapor {
	const FacetMoreRowsConnected: React.ComponentClass<IFacetMoreRowsProps>;

}
declare module ReactVapor {
	interface IFacetMoreToggleOwnProps extends React.ClassAttributes<FacetMoreToggle> {
	    facet: string;
	    moreLabel?: string;
	}
	interface IFacetMoreToggleStateProps {
	    isOpened?: boolean;
	}
	interface IFacetMoreToggleDispatchProps {
	    onToggleMore?: (facet: string) => void;
	}
	interface IFacetMoreToggleProps extends IFacetMoreToggleOwnProps, IFacetMoreToggleStateProps, IFacetMoreToggleDispatchProps {
	}
	const FACET_TOGGLE_MORE_LABEL: string;
	class FacetMoreToggle extends React.Component<IFacetMoreToggleProps, any> {
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	const FacetMoreToggleConnected: React.ComponentClass<IFacetMoreToggleProps>;

}
declare module ReactVapor {
	interface IFacetRowProps extends React.ClassAttributes<FacetRow> {
	    facetRow: IFacet;
	    facet: string;
	    onToggleFacet: (facetRow: IFacet) => void;
	    isChecked: boolean;
	    maxTooltipLabelLength?: number;
	    enableExclusions?: boolean;
	    excludeTooltipMessage?(facetsRowName: string): string;
	}
	class FacetRow extends React.Component<IFacetRowProps, any> {
	    static defaultProps;
	    readonly isExclude: boolean;
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	interface IFacet {
	    name: string;
	    formattedName: string;
	    tooltipLabel?: string;
	    count?: string;
	    exclude?: boolean;
	}
	interface IFacetOwnProps extends React.ClassAttributes<Facet> {
	    facet: IFacet;
	    facetRows: IFacet[];
	    toggleFacet: (facet: string, facetRow: IFacet) => void;
	    clearFacet: (facet: string) => void;
	    clearFacetLabel?: string;
	    maxRowsToShow?: number;
	    maxTooltipLabelLength?: number;
	    excludeTooltipMessage?(facetsRowName: string): string;
	}
	interface IFacetStateProps extends IReduxStatePossibleProps {
	    isOpened?: boolean;
	    selectedFacetRows?: IFacet[];
	}
	interface IFacetDispatchProps {
	    onRender?: (facet: string) => void;
	    onDestroy?: (facet: string) => void;
	    onToggleFacet?: (facet: string, facetRow: IFacet) => void;
	    onClearFacet?: (facet: string) => void;
	}
	interface IFacetChildrenProps {
	    moreLabel?: string;
	    filterPlaceholder?: string;
	    enableExclusions?: boolean;
	}
	interface IFacetProps extends IFacetOwnProps, IFacetStateProps, IFacetDispatchProps, IFacetChildrenProps {
	}
	const CLEAR_FACET_LABEL: string;
	class Facet extends React.Component<IFacetProps, any> {
	    static defaultProps;
	    componentWillMount(): void;
	    componentWillUnmount(): void;
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	interface IFlatSelectActionPayload extends IReduxActionsPayload {
	    id: string;
	    selectedOptionId?: string;
	}
	const FlatSelectActions: {
	    add: string;
	    remove: string;
	    select: string;
	};
	const addFlatSelect: (id: string, selectedOptionId: string) => IReduxAction<IFlatSelectActionPayload>;
	const removeFlatSelect: (id: string) => IReduxAction<IFlatSelectActionPayload>;
	const selectFlatSelect: (id: string, selectedOptionId: string) => IReduxAction<IFlatSelectActionPayload>;

}
declare module ReactVapor {
	interface IFlatSelectState {
	    id: string;
	    selectedOptionId?: string;
	}
	const flatSelectInitialState: IFlatSelectState;
	const flatSelectsInitialState: IFlatSelectState[];
	const flatSelectReducer: (state: IFlatSelectState, action: IReduxAction<IFlatSelectActionPayload>) => IFlatSelectState;
	const flatSelectsReducer: (state: IFlatSelectState[], action: IReduxAction<IFlatSelectActionPayload>) => IFlatSelectState[];

}
declare module ReactVapor {
	const FlippableAction: {
	    add: string;
	    remove: string;
	    changeSide: string;
	};
	interface IFlippablePayload {
	    id: string;
	}
	interface IFlippableChangeSidePayload extends IFlippablePayload {
	    flipped: boolean;
	}
	const addFlippable: (id: string) => IReduxAction<IFlippablePayload>;
	const removeFlippable: (id: string) => IReduxAction<IFlippablePayload>;
	const changeFlippableSide: (id: string, flipped: boolean) => IReduxAction<IFlippableChangeSidePayload>;

}
declare module ReactVapor {
	interface IFlippableState {
	    id: string;
	    flipped: boolean;
	}
	const flippableInitialState: IFlippableState;
	const flippablesInitialState: IFlippableState[];
	const flippableReducer: (state: IFlippableState, action: IReduxAction<any>) => IFlippableState;
	const flippablesReducer: (state: IFlippableState[], action: IReduxAction<IReduxActionsPayload>) => IFlippableState[];

}
declare module ReactVapor {
	interface IPromptActionPayload {
	    id: string;
	}
	interface IAddPromptActionPayload extends IPromptActionPayload {
	    options: IInlinePromptOptions;
	}
	const PromptActions: {
	    add: string;
	    remove: string;
	};
	const addPrompt: (id: string, options: IInlinePromptOptions) => IReduxAction<IAddPromptActionPayload>;
	const removePrompt: (id: string) => IReduxAction<IPromptActionPayload>;

}
declare module ReactVapor {
	interface IPromptState {
	    id: string;
	    options: IInlinePromptOptions;
	}
	const promptInitialState: IPromptState;
	const promptsInitialState: IPromptState[];
	const promptReducer: (state: IPromptState, action: IReduxAction<IReduxActionsPayload>) => IPromptState;
	const promptsReducer: (state: IPromptState[], action: IReduxAction<IReduxActionsPayload>) => IPromptState[];

}
declare module ReactVapor {
	const InputActions: {
	    add: string;
	    remove: string;
	    changeValue: string;
	    validateValue: string;
	    setDisabled: string;
	};
	interface IInputActionPayload {
	    id: string;
	    valid?: boolean;
	    value?: string;
	    disabled?: boolean;
	}
	const addInput: (id: string, value?: string, valid?: boolean, disabled?: boolean) => IReduxAction<IInputActionPayload>;
	const removeInput: (id: string) => IReduxAction<IInputActionPayload>;
	const changeInputValue: (id: string, value?: string, valid?: boolean) => IReduxAction<IInputActionPayload>;
	const validateInputValue: (id: string, valid?: boolean) => IReduxAction<IInputActionPayload>;
	const setDisabledInput: (id: string, disabled?: boolean) => IReduxAction<IInputActionPayload>;

}
declare module ReactVapor {
	interface IInputState {
	    id: string;
	    value: string;
	    valid: boolean;
	    disabled: boolean;
	}
	const inputInitialState: IInputState;
	const inputsInitialState: IInputState[];
	const inputReducer: (state: IInputState, action: IReduxAction<IReduxActionsPayload>) => IInputState;
	const inputsReducer: (state: IInputState[], action: IReduxAction<IReduxActionsPayload>) => IInputState[];

}
declare module ReactVapor {
	const LastUpdatedActions: {
	    addLastUpdated: string;
	    removeLastUpdated: string;
	    changeLastUpdated: string;
	};
	interface ILastUpdatedPayload {
	    id: string;
	}
	const addLastUpdated: (id: string) => IReduxAction<ILastUpdatedPayload>;
	const removeLastUpdated: (id: string) => IReduxAction<ILastUpdatedPayload>;
	const changeLastUpdated: (id: string) => IReduxAction<ILastUpdatedPayload>;

}
declare module ReactVapor {
	interface ILastUpdatedState {
	    id: string;
	    time: Date;
	}
	const lastUpdatedInitialState: ILastUpdatedState;
	const lastUpdatedCompositeInitialState: ILastUpdatedState[];
	const lastUpdatedReducer: (state: ILastUpdatedState, action: IReduxAction<IReduxActionsPayload>) => ILastUpdatedState;
	const lastUpdatedCompositeReducer: (state: ILastUpdatedState[], action: IReduxAction<IReduxActionsPayload>) => ILastUpdatedState[];

}
declare module ReactVapor {
	interface IListBoxState {
	    id: string;
	    selected: string[];
	    active?: number;
	}
	const listBoxInitialState: IListBoxState;
	const listBoxesInitialState: IListBoxState[];
	const listBoxReducer: (state: IListBoxState, action: IReduxAction<IListBoxPayload>) => IListBoxState;
	const listBoxesReducer: (state: IListBoxState[], action: IReduxAction<IListBoxPayload>) => IListBoxState[];

}
declare module ReactVapor {
	interface ILoadingState {
	    id: string;
	    isOn: boolean;
	}
	const loadingInitialState: ILoadingState;
	const loadingsInitialState: ILoadingState[];
	const loadingReducer: (state: ILoadingState, action: IReduxAction<IReduxActionsPayload>) => ILoadingState;
	const loadingsReducer: (state: ILoadingState[], action: IReduxAction<IReduxActionsPayload>) => ILoadingState[];

}
declare module ReactVapor {
	const MenuActions: {
	    add: string;
	    remove: string;
	    toggle: string;
	    updateList: string;
	};
	interface IMenuPayload {
	    id: string;
	    open?: boolean;
	    list?: IItemBoxProps[];
	}
	const addMenu: (id: string, list: IItemBoxProps[]) => IReduxAction<IMenuPayload>;
	const removeMenu: (id: string) => IReduxAction<IMenuPayload>;
	const toggleMenu: (id: string, open?: boolean) => IReduxAction<IMenuPayload>;
	const updateListMenu: (id: string, list: IItemBoxProps[]) => IReduxAction<IMenuPayload>;

}
declare module ReactVapor {
	interface IMenusState {
	    [id: string]: IMenuState;
	}
	interface IMenuState {
	    id: string;
	    open: boolean;
	    list: IItemBoxProps[];
	}
	const menuInitialState: IMenuState;
	const menuCompositeInitialState: IMenusState;
	const menuReducer: (state: IMenuState, action: IReduxAction<IMenuPayload>) => IMenuState;
	const menuCompositeReducer: (state: IMenusState, action: IReduxAction<IMenuPayload>) => IMenusState;

}
declare module ReactVapor {
	interface IModalActionPayload {
	    id?: string;
	    ids?: string[];
	}
	const ModalAction: {
	    openModal: string;
	    addModal: string;
	    removeModal: string;
	    closeModals: string;
	};
	const closeModal: (id: string) => IReduxAction<IModalActionPayload>;
	const openModal: (id: string) => IReduxAction<IModalActionPayload>;
	const addModal: (id: string) => IReduxAction<IModalActionPayload>;
	const removeModal: (id: string) => IReduxAction<IModalActionPayload>;
	const closeModals: (ids: string[]) => IReduxAction<IModalActionPayload>;

}
declare module ReactVapor {
	interface IModalState {
	    id: string;
	    isOpened: boolean;
	}
	const modalInitialState: IModalState;
	const modalsInitialState: IModalState[];
	const modalReducer: (state: IModalState, action: IReduxAction<IModalActionPayload>) => IModalState;
	const modalsReducer: (state: IModalState[], action: IReduxAction<IModalActionPayload>) => IModalState[];
	const openModalsReducer: (state: string[], action: IReduxAction<IModalActionPayload>) => string[];

}
declare module ReactVapor {
	/// <reference types="react" />
	type JSXRenderable = JSX.Element | JSX.Element[] | string | number;

}
declare module ReactVapor {
	interface IButtonProps extends IBaseActionOptions {
	    small?: boolean;
	    classes?: string[];
	}
	class Button extends React.Component<IButtonProps, {}> {
	    static defaultProps;
	    getTemplate(buttonClass: string): JSX.Element;
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	interface IBlankSlateProps extends React.ClassAttributes<BlankSlate> {
	    title?: string;
	    description?: string;
	    buttons?: IBaseActionOptions[];
	    withModal?: boolean;
	    classes?: string[];
	    containerClasses?: string[];
	    svgName?: string;
	    svgClass?: string;
	}
	class BlankSlate extends React.Component<IBlankSlateProps, {}> {
	    static defaultProps;
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	interface IOptionsCycleOwnProps extends React.ClassAttributes<OptionsCycle> {
	    options: string[];
	    id?: string;
	    startAt?: number;
	    isInline?: boolean;
	}
	interface IOptionsCycleStateProps {
	    currentOption?: number;
	}
	interface IOptionsCycleDispatchProps {
	    onRender?: (index: number) => void;
	    onDestroy?: () => void;
	    onChange?: (index: number) => void;
	}
	interface IOptionsCycleProps extends IOptionsCycleOwnProps, IOptionsCycleStateProps, IOptionsCycleDispatchProps {
	}
	class OptionsCycle extends React.Component<IOptionsCycleProps, any> {
	    componentWillMount(): void;
	    componentWillUnmount(): void;
	    componentWillReceiveProps(nextProps: IOptionsCycleProps): void;
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	const OptionsCycleActions: {
	    add: string;
	    remove: string;
	    change: string;
	};
	interface IOptionsCyclePayload {
	    id: string;
	}
	interface IChangeOptionsCyclePayload extends IOptionsCyclePayload {
	    currentOption: number;
	}
	const addOptionsCycle: (id: string, currentOption?: number) => IReduxAction<IChangeOptionsCyclePayload>;
	const removeOptionsCycle: (id: string) => IReduxAction<IOptionsCyclePayload>;
	const changeOptionsCycle: (id: string, currentOption: number) => IReduxAction<IChangeOptionsCyclePayload>;

}
declare module ReactVapor {
	const OptionsCycleConnected: React.ComponentClass<IOptionsCycleProps>;

}
declare module ReactVapor {
	const TableHeaderCellActions: {
	    add: string;
	    remove: string;
	    sort: string;
	};
	interface ITableHeaderCellActionPayload {
	    id: string;
	    attributeToSort?: string;
	    tableId?: string;
	}
	const addHeaderCell: (id: string, attributeToSort: string, tableId: string) => IReduxAction<ITableHeaderCellActionPayload>;
	const removeHeaderCell: (id: string) => IReduxAction<ITableHeaderCellActionPayload>;
	const sortFromHeaderCell: (id: string, attributeToSort: string, tableId: string) => IReduxAction<ITableHeaderCellActionPayload>;

}
declare module ReactVapor {
	const getNextTableSortingOrder: (sortedState: TableSortingOrder) => TableSortingOrder;
	const getTableChildComponentId: (tableId: string, childComponent: TableChildComponent) => string;
	const getTableLoadingIds: (tableId: string) => string[];
	const convertInitialCollectionToDataById: (collection: {
	    [key: string]: any;
	}[], attributeNameForId: string) => ITableRowData;
	const convertDataByIdToCollection: (dataById: ITableRowData, keepIdAttribute?: boolean) => {
	    [key: string]: any;
	}[];

}
declare module ReactVapor {
	interface ITableById {
	    [id: string]: {
	        id: string;
	        [attribute: string]: any;
	    };
	}
	interface ITableData {
	    byId: ITableById;
	    allIds: string[];
	    displayedIds: string[];
	    totalEntries: number;
	    totalPages: number;
	    selectedIds?: string[];
	    IS_DEFAULT_TABLE_DATA?: boolean;
	}
	interface ITablesState {
	    [id: string]: ITableState;
	}
	type attributeName = any;
	type attributeValue = any;
	interface ITableCompositeState {
	    id: string;
	    data: ITableData;
	    isInError: boolean;
	    isLoading: boolean;
	    filter: string;
	    page: number;
	    perPage: number;
	    sortState: {
	        attribute: attributeName;
	        order: TableSortingOrder;
	    };
	    predicates: {
	        [attributeNameAssociatedToPredicate: string]: attributeValue;
	    };
	    from: Date;
	    to: Date;
	    actions?: IActionOptions[];
	}
	interface ITableState {
	    id: string;
	    data: ITableData;
	    isInError: boolean;
	    isLoading: boolean;
	    filterId: string;
	    datePickerId: string;
	    datePickerRangeId: string;
	    paginationId: string;
	    perPageId: string;
	    predicateIds: string[];
	    tableHeaderCellId: string;
	    yPosition: number;
	}
	const tableInitialState: ITableState;
	const tablesInitialState: {
	    [tableId: string]: ITableState;
	};
	const updateSelectedIDs: (state: ITableState, oldSelectedIds: string[]) => ITableState;
	const tableReducer: (state: ITableState, action: IReduxAction<ITableActionPayload>) => ITableState;
	const tablesReducer: (tablesState: {
	    [tableId: string]: ITableState;
	}, action: IReduxAction<any>) => any;

}
declare module ReactVapor {
	enum TableSortingOrder {
	    UNSORTED = "UNSORTED",
	    ASCENDING = "ASCENDING",
	    DESCENDING = "DESCENDING"
	}
	const DEFAULT_TABLE_PER_PAGE = 100000;
	const DEFAULT_TABLE_DATA: ITableData;
	const TABLE_PREDICATE_DEFAULT_VALUE = "ALL";
	const TOGGLE_ARROW_CELL_COUNT = 1;
	const TABLE_ID_PREFIX = "react-vapor-table-";
	const TABLE_PREDICATE_ID_PREFIX = "predicate-";
	enum TableChildComponent {
	    ACTION_BAR = "action-bar",
	    DATEPICKER = "datepicker",
	    DATEPICKER_RANGE = "datepicker-date-range",
	    FILTER = "filter",
	    NAVIGATION = "navigation",
	    PAGINATION = "pagination",
	    PER_PAGE = "per-page",
	    LOADING_TABLE = "loading-table",
	    LOADING_ACTION_BAR = "loading-action-bar",
	    LOADING_NAVIGATION = "loading-navigation",
	    BLANKSLATE = "blankslate",
	    PREDICATE = "predicate",
	    TABLE_HEADER = "table-header",
	    TABLE_HEADER_CELL = "table-header-cell",
	    TABLE_ROW_CELL = "table-row-cell",
	    TABLE_HEADING_ROW = "table-heading-row",
	    TABLE_COLLAPSIBLE_ROW = "table-collapsible-row",
	    TABLE_ROW_WRAPPER = "table-row-wrapper",
	    LAST_UPDATED = "last-updated"
	}

}
declare module ReactVapor {
	interface ITableHeaderCellOwnProps extends React.ClassAttributes<TableHeaderCell> {
	    title: React.ReactNode;
	    id?: string;
	    attributeToSort?: string;
	    tableId?: string;
	    className?: string;
	    withFixedHeader?: boolean;
	    onClickCallback?: (e) => void;
	}
	interface ITableHeaderStateProps {
	    sorted?: TableSortingOrder;
	}
	interface ITableHeaderCellDispatchProps {
	    onMount?: () => void;
	    onSort?: () => void;
	    onUnmount?: () => void;
	}
	interface ITableHeaderCellProps extends ITableHeaderCellOwnProps, ITableHeaderStateProps, ITableHeaderCellDispatchProps {
	}
	class TableHeaderCell extends React.Component<ITableHeaderCellProps, any> {
	    static defaultProps;
	    componentDidMount(): void;
	    componentWillUnmount(): void;
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	interface ITableHeaderCellState {
	    id: string;
	    tableId: string;
	    sorted: TableSortingOrder;
	    attributeToSort?: string;
	}
	interface ITableHeaderCellsState {
	    [id: string]: ITableHeaderCellState;
	}
	const tableHeaderCellInitialState: ITableHeaderCellState;
	const tableHeaderCellsInitialState: ITableHeaderCellsState;
	const tableHeaderCellReducer: (state: ITableHeaderCellState, action: IReduxAction<IReduxActionsPayload>) => ITableHeaderCellState;
	const tableHeaderCellsReducer: (state: ITableHeaderCellsState, action: IReduxAction<IReduxActionsPayload>) => ITableHeaderCellsState;

}
declare module ReactVapor {
	const TableHeaderCellConnected: React.ComponentClass<ITableHeaderCellProps>;

}
declare module ReactVapor {
	interface ITableHeaderProps extends React.ClassAttributes<TableHeader>, IReduxStatePossibleProps {
	    columns: ITableHeaderCellProps[];
	    headerClass?: string;
	}
	class TableHeader extends React.Component<ITableHeaderProps, any> {
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	const CalendarSelectionRuleType: {
	    all: string;
	    lower: string;
	    upper: string;
	    range: string;
	};
	interface ICalendarSelectionRule {
	    test: (date: Date, secondDate?: Date) => boolean;
	    isFor: string;
	}
	interface ICalendarOwnProps extends React.ClassAttributes<Calendar> {
	    id?: string;
	    months?: string[];
	    startingMonth?: number;
	    years?: string[];
	    startingYear?: number;
	    days?: string[];
	    startingDay?: number;
	    selectionRules?: ICalendarSelectionRule[];
	    isLinkedToDateRange?: boolean;
	    simple?: boolean;
	}
	interface ICalendarStateProps extends IReduxStatePossibleProps {
	    selectedMonth?: number;
	    selectedYear?: number;
	    calendarSelection?: IDatePickerState[];
	}
	interface ICalendarDispatchProps {
	    onClick?: (pickerId: string, isUpperLimit: boolean, value: Date) => void;
	    onDateChange?: (cycleId: string, newValue: number) => void;
	    onSelectUnselectable?: (pickerId: string) => void;
	}
	interface ICalendarProps extends ICalendarOwnProps, ICalendarStateProps, ICalendarDispatchProps {
	}
	const DEFAULT_MONTHS: string[];
	const DEFAULT_YEARS: string[];
	const DEFAULT_DAYS: string[];
	const MONTH_PICKER_ID: string;
	const YEAR_PICKER_ID: string;
	class Calendar extends React.Component<ICalendarProps, any> {
	    static defaultProps;
	    componentWillReceiveProps(nextProps: ICalendarProps): void;
	    fillInDayInfos(day: IDay): IDay;
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	type ClassNameTypes = string | string[] | {
	    [key: string]: boolean;
	};
	type IClassName = ClassNameTypes | ClassNameTypes[];
	interface IAdditionalClass {
	    className: string;
	    condition?: (data: any) => boolean;
	}
	const getAdditionalClasses: (additionalClasses: IAdditionalClass[], dataToUse: any) => IClassName;

}
declare module ReactVapor {
	interface ILabelProps {
	    htmlFor?: string;
	    type?: string;
	    classes?: string[];
	    validMessage?: string;
	    invalidMessage?: string;
	}
	class Label extends React.Component<ILabelProps, any> {
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	interface IInputOwnProps {
	    id?: string;
	    name?: string;
	    type?: string;
	    classes?: IClassName;
	    innerInputClasses?: IClassName;
	    defaultValue?: string;
	    placeholder?: string;
	    defaultChecked?: boolean;
	    readOnly?: boolean;
	    validate?: (value: any) => boolean;
	    labelTitle?: string;
	    labelProps?: ILabelProps;
	    onKeyUp?: (event) => void;
	    onBlur?: (value: string) => void;
	    validateOnChange?: boolean;
	    disabledOnMount?: boolean;
	    validateOnMount?: boolean;
	    autoFocus?: boolean;
	}
	interface IInputStateProps {
	    checked?: boolean;
	    disabled?: boolean;
	    value?: string;
	    valid?: boolean;
	    indeterminate?: boolean;
	}
	interface IInputDispatchProps {
	    onDestroy?: () => void;
	    onRender?: (value?: string, valid?: boolean, disabled?: boolean) => void;
	    onChange?: (value?: string, valid?: boolean) => void;
	    onClick?: (e) => void;
	}
	interface IInputProps extends IInputOwnProps, IInputStateProps, IInputDispatchProps {
	}
	interface IInputState {
	    valid: boolean;
	}
	class Input extends React.Component<IInputProps, IInputState> {
	    static defaultProps;
	    constructor(props: IInputProps, state: IInputState);
	    componentWillMount(): void;
	    componentWillUnmount(): void;
	    componentDidUpdate(prevProps: IInputProps): void;
	    reset(): void;
	    getInnerValue(): string;
	    validate(): void;
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	interface IModalFooterProps {
	    classes?: IClassName;
	}
	class ModalFooter extends React.Component<IModalFooterProps, {}> {
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	const OptionPickerActions: {
	    add: string;
	    remove: string;
	    change: string;
	    reset: string;
	};
	interface IOptionPickerPayload {
	    id: string;
	}
	interface IChangeOptionPayload extends IOptionPickerPayload {
	    label: string;
	    value: string;
	}
	const addOptionPicker: (id: string) => IReduxAction<IOptionPickerPayload>;
	const removeOptionPicker: (id: string) => IReduxAction<IOptionPickerPayload>;
	const changeOptionPicker: (id: string, label: string, value: string) => IReduxAction<IChangeOptionPayload>;
	const resetOptionPickers: (id: string) => IReduxAction<IOptionPickerPayload>;

}
declare module ReactVapor {
	const CalendarConnected: React.ComponentClass<ICalendarProps>;

}
declare module ReactVapor {
	interface IOption {
	    label: string;
	    value: () => string;
	    [key: string]: any;
	}
	interface IOptionProps extends React.ClassAttributes<Option> {
	    option: IOption;
	    isActive: boolean;
	    onClick: (value: string, label: string) => void;
	}
	class Option extends React.Component<IOptionProps, any> {
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	interface IOptionPickerOwnProps extends React.ClassAttributes<OptionPicker> {
	    id?: string;
	    options: IOption[];
	}
	interface IOptionPickerStateProps {
	    activeLabel?: string;
	}
	interface IOptionPickerDispatchProps {
	    onRender?: () => void;
	    onDestroy?: () => void;
	    onClick?: (value: string, label: string) => void;
	}
	interface IOptionPickerProps extends IOptionPickerOwnProps, IOptionPickerStateProps, IOptionPickerDispatchProps {
	}
	class OptionPicker extends React.Component<IOptionPickerProps, any> {
	    componentWillMount(): void;
	    componentWillUnmount(): void;
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	interface IOptionPickerState {
	    id: string;
	    selectedLabel: string;
	    selectedValue: string;
	}
	const optionPickerInitialState: IOptionPickerState;
	const optionPickersInitialState: IOptionPickerState[];
	const optionPickerReducer: (state: IOptionPickerState, action: IReduxAction<IReduxActionsPayload>) => IOptionPickerState;
	const optionPickersReducer: (state: IOptionPickerState[], action: IReduxAction<IReduxActionsPayload>) => IOptionPickerState[];

}
declare module ReactVapor {
	const OptionPickerConnected: React.ComponentClass<IOptionPickerProps>;

}
declare module ReactVapor {
	const DatesSelectionConnected: React.ComponentClass<IDatesSelectionProps>;

}
declare module ReactVapor {
	interface IDatesSelectionBox {
	    title: string;
	    quickOptions?: IOption[];
	    isRange?: boolean;
	    rangeLimit?: IRangeLimit;
	    withTime?: boolean;
	    hasSetToNowButton?: boolean;
	    color?: string;
	}
	interface IDatePickerBoxOwnProps extends React.ClassAttributes<DatePickerBox> {
	    id?: string;
	    datesSelectionBoxes: IDatesSelectionBox[];
	    setToNowTooltip?: string;
	    isClearable?: boolean;
	    clearLabel?: string;
	    initiallyUnselected?: boolean;
	    simple?: boolean;
	    footer?: JSX.Element;
	    onClear?: () => void;
	}
	interface IDatePickerBoxStateProps extends IReduxStatePossibleProps {
	}
	interface IDatePickerBoxChildrenProps {
	    months?: string[];
	    startingMonth?: number;
	    years?: string[];
	    startingYear?: number;
	    days?: string[];
	    startingDay?: number;
	    selectionRules?: ICalendarSelectionRule[];
	    lowerLimitPlaceholder?: string;
	    upperLimitPlaceholder?: string;
	    isLinkedToDateRange?: boolean;
	    initialDateRange?: DatePickerDateRange;
	}
	const DEFAULT_CLEAR_DATE_LABEL = "Clear";
	interface IDatePickerBoxProps extends IDatePickerBoxOwnProps, IDatePickerBoxStateProps, IDatePickerBoxChildrenProps {
	}
	class DatePickerBox extends React.Component<IDatePickerBoxProps, any> {
	    static defaultProps;
	    static getCalendarId: (datePickerId: string) => string;
	    componentWillMount(): void;
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	interface IDatePickerDropdownOwnProps extends React.ClassAttributes<DatePickerDropdown> {
	    label?: string;
	    id?: string;
	    applyLabel?: string;
	    cancelLabel?: string;
	    toLabel?: string;
	    onRight?: boolean;
	    onBeforeApply?: () => void;
	    extraDropdownClasses?: string[];
	    extraDropdownToggleClasses?: string[];
	    renderDatePickerWhenClosed?: boolean;
	    initiallyUnselected?: boolean;
	    isClearable?: boolean;
	    attributeName?: string;
	    readonly?: boolean;
	}
	interface IDatePickerDropdownChildrenProps extends IDatePickerBoxChildrenProps {
	    datesSelectionBoxes: IDatesSelectionBox[];
	    setToNowTooltip?: string;
	    clearLabel?: string;
	    months?: string[];
	    startingMonth?: number;
	    years?: string[];
	    startingYear?: number;
	    days?: string[];
	    startingDay?: number;
	    selectionRules?: ICalendarSelectionRule[];
	    lowerLimitPlaceholder?: string;
	    upperLimitPlaceholder?: string;
	    isLinkedToDateRange?: boolean;
	    simple?: boolean;
	    initialDateRange?: DatePickerDateRange;
	}
	interface IDatePickerDropdownStateProps extends IReduxStatePossibleProps {
	    isOpened?: boolean;
	    datePicker?: IDatePickerState;
	}
	interface IDatePickerDropdownDispatchProps {
	    onApply?: () => void;
	    onCancel?: (currentMonth: number, currentYear: number, isOpened: boolean) => void;
	    onRender?: () => void;
	    onDestroy?: () => void;
	    onClick?: (datePicker: IDatePickerState) => void;
	    onDocumentClick?: () => void;
	    onClear?: () => void;
	}
	interface IDatePickerDropdownProps extends IDatePickerDropdownOwnProps, IDatePickerDropdownStateProps, IDatePickerDropdownDispatchProps, IDatePickerDropdownChildrenProps {
	}
	const DEFAULT_DATE_PICKER_DROPDOWN_LABEL: string;
	const DEFAULT_APPLY_DATE_LABEL: string;
	const DEFAULT_CANCEL_DATE_LABEL: string;
	const DEFAULT_TO_LABEL: string;
	const DEFAULT_EXTRA_DROPDOWN_CLASSES: string[];
	const DEFAULT_EXTRA_DROPDOWN_TOGGLE_CLASSES: string[];
	const DEFAULT_RENDER_DATEPICKER_WHEN_CLOSED: boolean;
	const DEFAULT_INITIALY_UNSELECTED: boolean;
	class DatePickerDropdown extends React.Component<IDatePickerDropdownProps, any> {
	    static defaultProps;
	    componentWillMount(): void;
	    componentWillUnmount(): void;
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	interface ILoadingOwnProps extends React.ClassAttributes<Loading> {
	    id?: string;
	    className?: string;
	}
	interface ILoadingDispatchProps {
	    onRender?: () => void;
	    onDestroy?: () => void;
	}
	interface ILoadingProps extends ILoadingOwnProps, ILoadingDispatchProps {
	}
	class Loading extends React.Component<ILoadingProps & React.HTMLProps<HTMLDivElement>, any> {
	    componentWillMount(): void;
	    componentWillUnmount(): void;
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	const LoadingConnected: React.ComponentClass<ILoadingProps>;

}
declare module ReactVapor {
	interface INavigationPaginationSelectProps extends React.ClassAttributes<NavigationPaginationSelect> {
	    selected: boolean;
	    pageNb: number;
	    onPageClick: (pageNb: number) => void;
	}
	class NavigationPaginationSelect extends React.Component<INavigationPaginationSelectProps, any> {
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	interface INavigationPaginationOwnProps extends React.ClassAttributes<NavigationPagination> {
	    id?: string;
	    totalPages: number;
	    numberOfPagesToShow?: number;
	    previousLabel?: string;
	    nextLabel?: string;
	    loadingIds?: string[];
	    hidePages?: boolean;
	}
	interface INavigationPaginationStateProps {
	    currentPage?: number;
	}
	interface INavigationPaginationDispatchProps {
	    onRender?: () => void;
	    onDestroy?: () => void;
	    onPageClick?: (pageNb: number) => void;
	}
	interface INavigationPaginationProps extends INavigationPaginationOwnProps, INavigationPaginationStateProps, INavigationPaginationDispatchProps {
	}
	const NUMBER_OF_PAGES_SHOWING: number;
	const PREVIOUS_LABEL: string;
	const NEXT_LABEL: string;
	class NavigationPagination extends React.Component<INavigationPaginationProps, any> {
	    componentWillMount(): void;
	    componentWillUnmount(): void;
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	interface IPaginationActionPayload {
	    id: string;
	}
	interface IChangePaginationActionPayload extends IPaginationActionPayload {
	    pageNb: number;
	}
	const PaginationActions: {
	    add: string;
	    remove: string;
	    changePage: string;
	    reset: string;
	};
	const addPagination: (id: string) => IReduxAction<IPaginationActionPayload>;
	const removePagination: (id: string) => IReduxAction<IPaginationActionPayload>;
	const changePage: (id: string, pageNb: number) => IReduxAction<IChangePaginationActionPayload>;
	const resetPaging: (id: string) => IReduxAction<IChangePaginationActionPayload>;

}
declare module ReactVapor {
	const NavigationPaginationConnected: React.ComponentClass<INavigationPaginationProps>;

}
declare module ReactVapor {
	interface INavigationPerPageSelectOwnProps extends React.ClassAttributes<NavigationPerPageSelect> {
	    perPageNb: number;
	    selected: boolean;
	    onPerPageClick: (perPageNb: number) => void;
	}
	interface INavigationPerPageSelectProps extends INavigationPerPageSelectOwnProps {
	}
	class NavigationPerPageSelect extends React.Component<INavigationPerPageSelectProps, any> {
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	interface INavigationPerPageOwnProps extends React.ClassAttributes<NavigationPerPage> {
	    id?: string;
	    totalEntries: number;
	    label?: string;
	    perPageNumbers?: number[];
	    loadingIds?: string[];
	    initialPosition?: number;
	}
	interface INavigationPerPageStateProps {
	    currentPerPage?: number;
	    currentPage?: number;
	}
	interface INavigationPerPageDispatchProps {
	    onRender?: (perPageNb: number) => void;
	    onDestroy?: () => void;
	    onPerPageClick?: (perPageNb: number, oldPerPageNb: number, currentPage: number) => void;
	}
	interface INavigationPerPageProps extends INavigationPerPageOwnProps, INavigationPerPageStateProps, INavigationPerPageDispatchProps {
	}
	const PER_PAGE_NUMBERS: number[];
	const PER_PAGE_LABEL: string;
	class NavigationPerPage extends React.Component<INavigationPerPageProps> {
	    static defaultProps;
	    componentWillMount(): void;
	    componentWillUnmount(): void;
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	interface IPerPageActionPayload {
	    id: string;
	}
	interface IChangePerPageActionPayload extends IPerPageActionPayload {
	    perPage: number;
	}
	const PerPageActions: {
	    add: string;
	    remove: string;
	    change: string;
	};
	const addPerPage: (id: string, perPage: number) => IReduxAction<IChangePerPageActionPayload>;
	const removePerPage: (id: string) => IReduxAction<IPerPageActionPayload>;
	const changePerPage: (id: string, perPage: number) => IReduxAction<IChangePerPageActionPayload>;

}
declare module ReactVapor {
	interface IPerPageState {
	    id: string;
	    perPage: number;
	}
	const perPageInitialState: IPerPageState;
	const perPageCompositeInitialState: IPerPageState[];
	const perPageReducer: (state: IPerPageState, action: IReduxAction<IReduxActionsPayload>) => IPerPageState;
	const perPageCompositeReducer: (state: IPerPageState[], action: IReduxAction<IReduxActionsPayload>) => IPerPageState[];

}
declare module ReactVapor {
	const NavigationPerPageConnected: React.ComponentClass<INavigationPerPageProps>;

}
declare module ReactVapor {
	interface INavigationOwnProps extends React.ClassAttributes<Navigation> {
	    id?: string;
	    totalPages: number;
	    totalEntries: number;
	    loadingIds?: string[];
	}
	interface INavigationChildrenProps {
	    numberOfPagesToShow?: number;
	    previousLabel?: string;
	    nextLabel?: string;
	    onPageClick?: (pageNb: number) => void;
	    perPageLabel?: string;
	    perPageNumbers?: number[];
	    onPerPageClick?: () => void;
	    hidePages?: boolean;
	    currentPerPage?: number;
	    currentPage?: number;
	    initialPosition?: number;
	}
	interface INavigationStateProps extends IReduxStatePossibleProps {
	    isLoading?: boolean;
	}
	interface INavigationProps extends INavigationOwnProps, INavigationChildrenProps, INavigationStateProps {
	}
	class Navigation extends React.Component<INavigationProps, any> {
	    static defaultProps;
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	const InlinePromptConnected: React.ComponentClass<IInlinePromptProps>;

}
declare module ReactVapor {
	const ActionBarConnected: React.ComponentClass<IActionBarProps>;

}
declare module ReactVapor {
	const DatePickerDropdownConnected: React.ComponentClass<IDatePickerDropdownProps>;

}
declare module ReactVapor {
	/// <reference types="react" />
	const DropdownSearchConnected: React.ComponentClass<IDropdownSearchProps>;

}
declare module ReactVapor {
	/// <reference types="react" />
	const TableChildActionBar: (props: ITableProps) => JSX.Element;

}
declare module ReactVapor {
	/// <reference types="react" />
	interface ITableChildBlankSlateProps extends ITableProps {
	}
	const TableChildBlankSlate: (props: ITableChildBlankSlateProps) => JSX.Element;

}
declare module ReactVapor {
	interface IErrorSection {
	    errorDescription: string;
	    errorPrecision: string;
	    errorTroubleshoot: string;
	    errorStatus: string;
	    errorCode: string;
	}
	interface ITableErrorProps extends React.ClassAttributes<TableError> {
	    error: IErrorSection;
	    descriptionLabel?: string;
	    troubleshootingLabel?: string;
	    errorCodeLabel?: string;
	}
	const DESCRIPTION_LABEL: string;
	const TROUBLESHOOTING_LABEL: string;
	const ERROR_CODE_LABEL: string;
	class TableError extends React.Component<ITableErrorProps, any> {
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	interface ITableCollapsibleRowOwnProps extends React.ClassAttributes<TableCollapsibleRow> {
	    id: string;
	    isInError?: boolean;
	    nbColumns: number;
	}
	interface ITableCollapsibleRowStateProps {
	    opened?: boolean;
	}
	interface ITableCollapsibleRowChildrenProps {
	    error?: IErrorSection;
	    descriptionLabel?: string;
	    troubleshootingLabel?: string;
	    errorCodeLabel?: string;
	}
	interface ITableCollapsibleRowProps extends ITableCollapsibleRowOwnProps, ITableCollapsibleRowStateProps, ITableCollapsibleRowChildrenProps {
	}
	class TableCollapsibleRow extends React.Component<ITableCollapsibleRowProps, any> {
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	const TableRowActions: {
	    add: string;
	    remove: string;
	    select: string;
	    toggleOpen: string;
	    unselectAll: string;
	};
	interface ITableRowActionPayload {
	    id?: string;
	    tableId?: string;
	    rowId?: string;
	    opened?: boolean;
	}
	const addRow: (id: string, tableId?: string) => IReduxAction<ITableRowActionPayload>;
	const removeRow: (id: string) => IReduxAction<ITableRowActionPayload>;
	const selectRow: (id: string, tableId?: string, rowId?: string) => IReduxAction<ITableRowActionPayload>;
	const toggleRowOpened: (id: string, tableId?: string, rowId?: string, opened?: boolean) => IReduxAction<ITableRowActionPayload>;
	const unselectAllRows: (tableId?: string) => IReduxAction<ITableRowActionPayload>;

}
declare module ReactVapor {
	interface ITableRowState {
	    id: string;
	    opened: boolean;
	    selected: boolean;
	    tableId?: string;
	    rowId?: string;
	}
	const tableRowInitialState: ITableRowState;
	const tableRowsInitialState: ITableRowState[];
	const tableRowReducer: (state: ITableRowState, action: IReduxAction<ITableRowActionPayload>) => ITableRowState;
	const tableRowsReducer: (state: ITableRowState[], action: IReduxAction<ITableRowActionPayload>) => ITableRowState[];

}
declare module ReactVapor {
	const TableCollapsibleRowConnected: React.ComponentClass<ITableCollapsibleRowProps>;

}
declare module ReactVapor {
	interface ITableCollapsibleRowWrapperProps {
	    children?: React.ReactNode;
	    className?: string;
	}
	const TableCollapsibleRowWrapper: (props?: ITableCollapsibleRowWrapperProps) => JSX.Element;

}
declare module ReactVapor {
	class EventUtils {
	    static isClickingInsideElementWithClassname: (e, classname: string) => boolean;
	}

}
declare module ReactVapor {
	interface ITableCollapsibleRowToggleProps extends React.ClassAttributes<TableCollapsibleRowToggle> {
	    isExpanded: boolean;
	}
	class TableCollapsibleRowToggle extends React.Component<ITableCollapsibleRowToggleProps, any> {
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	interface ITableHeadingRowOwnProps extends React.ClassAttributes<TableHeadingRow> {
	    id?: string;
	    tableId?: string;
	    rowId?: string;
	    isCollapsible: boolean;
	    onClickCallback?: () => void;
	    onDoubleClick?: () => void;
	    className?: string;
	    isMultiSelect?: boolean;
	    selectionDisabled?: boolean;
	    tableHasCollapsibleRow?: boolean;
	}
	interface ITableHeadingRowStateProps {
	    opened?: boolean;
	    selected?: boolean;
	}
	interface ITableHeadingRowDispatchProps {
	    onRender?: () => void;
	    onDestroy?: () => void;
	    onClick?: (hasMultipleSelectedRow: boolean) => void;
	}
	interface ITableHeadingRowProps extends ITableHeadingRowOwnProps, ITableHeadingRowStateProps, ITableHeadingRowDispatchProps {
	}
	class TableHeadingRow extends React.Component<ITableHeadingRowProps, any> {
	    componentWillMount(): void;
	    componentWillUnmount(): void;
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	const TableHeadingRowConnected: React.ComponentClass<ITableHeadingRowProps>;

}
declare module ReactVapor {
	/// <reference types="react" />
	interface ITableBodyInheritedFromTableProps {
	    getActions?: (rowData?: IData) => IActionOptions[];
	    headingAttributes: ITableHeadingAttribute[];
	    collapsibleFormatter?: (tableRowData: IData) => JSXRenderable;
	    additionalRowClasses?: IAdditionalClass[];
	    withoutHoverOnRow?: boolean;
	}
	interface ITableChildBodyProps extends ITableBodyInheritedFromTableProps {
	    tableId: string;
	    rowData: IData;
	    isLoading: boolean;
	    onRowClick?: (actions: IActionOptions[]) => void;
	    isMultiSelect: boolean;
	    withoutHoverOnRow?: boolean;
	    handleOnRowClick?: (actions: IActionOptions[], rowData: IData) => void;
	}
	const TableChildBody: (props: ITableChildBodyProps) => JSX.Element;

}
declare module ReactVapor {
	/// <reference types="react" />
	const TableChildHeader: (props: ITableProps) => JSX.Element;

}
declare module ReactVapor {
	interface ILastUpdatedOwnProps extends React.ClassAttributes<LastUpdated> {
	    id?: string;
	    label?: string;
	}
	interface ILastUpdatedStateProps {
	    time?: Date;
	}
	interface ILastUpdatedDispatchProps {
	    onRender?: () => void;
	    onDestroy?: () => void;
	}
	interface ILastUpdatedProps extends ILastUpdatedOwnProps, ILastUpdatedStateProps, ILastUpdatedDispatchProps {
	}
	const LAST_UPDATE_LABEL: string;
	class LastUpdated extends React.Component<ILastUpdatedProps, any> {
	    componentWillMount(): void;
	    componentWillUnmount(): void;
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	const LastUpdatedConnected: React.ComponentClass<ILastUpdatedProps>;

}
declare module ReactVapor {
	/// <reference types="react" />
	const TableChildLastUpdated: (props: ITableProps) => JSX.Element;

}
declare module ReactVapor {
	/// <reference types="react" />
	interface ITableChildLoadingRowProps extends ITableProps {
	    isInitialLoad?: boolean;
	}
	const TableChildLoadingRow: (props: ITableChildLoadingRowProps) => JSX.Element;

}
declare module ReactVapor {
	const NavigationConnected: React.ComponentClass<INavigationProps>;

}
declare module ReactVapor {
	/// <reference types="react" />
	const TableChildNavigation: (props: ITableProps) => JSX.Element;

}
declare module ReactVapor {
	interface IData {
	    id: string;
	    [attribute: string]: any;
	}
	interface ITableRowData {
	    [id: string]: IData;
	}
	type IAttributeValue = any;
	interface IPredicateAttributes {
	    [attributeName: string]: IAttributeValue;
	}
	type IAttributeFormatter = (attributeValue: any, attributeName?: string, data?: IData) => JSXRenderable;
	type IAttributeNameOrValueFormatter = (attributeNameOrValue: string, data?: IData) => React.ReactNode;
	interface ITableHeadingAttribute {
	    attributeName: string;
	    titleFormatter: IAttributeNameOrValueFormatter | IAttributeFormatter;
	    filterFormatter?: IAttributeNameOrValueFormatter;
	    sort?: boolean;
	    sortByMethod?: (attributeValue: any, data?: IData) => string;
	    attributeFormatter?: IAttributeFormatter;
	}
	interface ITablePredicate {
	    props: IDropdownSearchProps;
	    attributeName: string;
	    attributeNameFormatter?: IAttributeNameOrValueFormatter;
	}
	interface ITableOwnProps extends React.ClassAttributes<Table>, ITableBodyInheritedFromTableProps {
	    id: string;
	    blankSlateDefault: IBlankSlateProps;
	    tableContainerClasses?: string[];
	    tableClasses?: string[];
	    tableBodyClasses?: string[];
	    initialTableData?: ITableData;
	    actionBar?: true | IActionBarProps;
	    blankSlateNoResultsOnAction?: IBlankSlateProps;
	    blankSlateOnError?: IBlankSlateProps;
	    datePicker?: IDatePickerDropdownProps;
	    filter?: true | IFilterBoxProps;
	    filterMethod?: (attributeValue: any, props: ITableOwnProps, filterValue: string) => boolean;
	    predicates?: ITablePredicate[];
	    prefixContent?: IContentProps;
	    navigation?: true | INavigationChildrenProps;
	    lastUpdatedLabel?: string;
	    withoutLastUpdated?: boolean;
	    withFixedHeader?: boolean;
	    handleOnRowClick?: (actions: IActionOptions[], rowData: IData) => void;
	    rowsMultiSelect?: boolean;
	    manual?: (tableOwnProps: ITableOwnProps, shouldResetPage: boolean, tableCompositeState: ITableCompositeState, previousTableCompositeState: ITableCompositeState) => IThunkAction;
	}
	interface ITableCompositeStateProps {
	    readonly tableCompositeState?: ITableCompositeState;
	    actions?: IActionOptions[];
	}
	interface ITableDispatchProps {
	    onDidMount?: () => void;
	    onUnmount?: () => void;
	    onWillUpdate?: (actions: IActionOptions[]) => void;
	    onModifyData?: (shouldResetPage: boolean, tableCompositeState: ITableCompositeState, previousTableCompositeState?: ITableCompositeState) => void;
	    onPredicateOptionClick?: (predicateId: string, option: IDropdownOption) => void;
	    onRowClick?: (actions: IActionOptions[], numberOfSelectedIds: number) => void;
	}
	interface ITableProps extends ITableOwnProps, ITableCompositeStateProps, ITableDispatchProps {
	}
	class Table extends React.Component<ITableProps> {
	    static defaultProps;
	    constructor(props: ITableProps);
	    componentDidMount(): void;
	    componentWillUpdate(nextProps: ITableProps): void;
	    componentDidUpdate(): void;
	    componentWillReceiveProps(nextProps: ITableProps): void;
	    componentWillUnmount(): void;
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	type ITableStateModifier = (state: ITableState) => ITableState;
	const TableActions: {
	    add: string;
	    remove: string;
	    inError: string;
	    modifyState: string;
	    updateSelectedIds: string;
	};
	interface ITableActionPayload {
	    id: string;
	    isInError?: boolean;
	    initialTableData?: ITableData;
	    initialPerPage?: number;
	    headingAttributeIds?: string[];
	    predicates?: ITablePredicate[];
	    tableStateModifier?: ITableStateModifier;
	    shouldResetPage?: boolean;
	    selectedIds?: string[];
	    hasMultipleSelectedRow?: boolean;
	}
	const addTable: (id: string, initialTableData: ITableData, predicates: ITablePredicate[]) => IReduxAction<ITableActionPayload>;
	const removeTable: (id: string) => IReduxAction<ITableActionPayload>;
	const setIsInError: (id: string, isInError: boolean) => IReduxAction<ITableActionPayload>;
	const modifyState: (id: string, tableStateModifier: ITableStateModifier, shouldResetPage: boolean) => IReduxAction<ITableActionPayload>;
	const updateSelectedRows: (id: string, selectedIds: string[], hasMultipleSelectedRow: boolean) => IReduxAction<ITableActionPayload>;

}
declare module ReactVapor {
	interface IPaginationState {
	    id: string;
	    pageNb: number;
	}
	const paginationInitialState: IPaginationState;
	const paginationCompositeInitialState: IPaginationState[];
	const paginationReducer: (state: IPaginationState, action: IReduxAction<IReduxActionsPayload>) => IPaginationState;
	const paginationCompositeReducer: (state: IPaginationState[], action: IReduxAction<IReduxActionsPayload>) => IPaginationState[];

}
declare module ReactVapor {
	interface IOptionsCycleState {
	    id: string;
	    currentOption: number;
	}
	const optionsCycleInitialState: IOptionsCycleState;
	const optionsCyclesInitialState: IOptionsCycleState[];
	const optionsCycleReducer: (state: IOptionsCycleState, action: IReduxAction<IReduxActionsPayload>) => IOptionsCycleState;
	const optionsCyclesReducer: (state: IOptionsCycleState[], action: IReduxAction<IReduxActionsPayload>) => IOptionsCycleState[];

}
declare module ReactVapor {
	const SearchBarActions: {
	    add: string;
	    remove: string;
	    toggleSearching: string;
	    toggleDisabled: string;
	    setValue: string;
	};
	interface ISearchBarActionPayload {
	    id: string;
	    disabled?: boolean;
	    searching?: boolean;
	    value?: string;
	}
	const addSearchBar: (id: string, disabled?: boolean) => IReduxAction<ISearchBarActionPayload>;
	const removeSearchBar: (id: string) => IReduxAction<ISearchBarActionPayload>;
	const toggleSearching: (id: string, searching: boolean) => {
	    type: string;
	    payload: {
	        id: string;
	        searching: boolean;
	    };
	};
	const toggleSearchBarDisabled: (id: string, disabled: boolean) => {
	    type: string;
	    payload: {
	        id: string;
	        disabled: boolean;
	    };
	};
	const setSearchBarValue: (id: string, value?: string) => {
	    type: string;
	    payload: {
	        id: string;
	        value: string;
	    };
	};

}
declare module ReactVapor {
	interface ISearchBarState {
	    id: string;
	    searching: boolean;
	    disabled: boolean;
	    value: string;
	}
	const searchBarDefaultState: ISearchBarState;
	const searchBarsInitialState: ISearchBarState[];
	const searchBarsReducer: (state: ISearchBarState[], action: IReduxAction<ISearchBarActionPayload>) => ISearchBarState[];

}
declare module ReactVapor {
	interface ISelectState {
	    id: string;
	    open: boolean;
	}
	const selectInitialState: ISelectState;
	const selectCompositeInitialState: ISelectState[];
	const selectReducer: (state: ISelectState, action: IReduxAction<ISelectPayload>) => ISelectState;
	const selectCompositeReducer: (state: ISelectState[], action: IReduxAction<ISelectPayload>) => ISelectState[];

}
declare module ReactVapor {
	interface ISubNavigationActionPayload {
	    id: string;
	    selected?: string;
	}
	const SubNavigationActions: {
	    add: string;
	    remove: string;
	    select: string;
	};
	const addSubNavigation: (id: string, itemsId: string[]) => IReduxAction<ISubNavigationActionPayload>;
	const removeSubNavigation: (id: string) => IReduxAction<ISubNavigationActionPayload>;
	const selectSubNavigation: (id: string, selected: string) => IReduxAction<ISubNavigationActionPayload>;

}
declare module ReactVapor {
	interface ISubNavigationState {
	    id: string;
	    selected: string;
	}
	const subNavigationInitialState: ISubNavigationState;
	const subNavigationsInitialState: ISubNavigationState[];
	const subNavigationReducer: (state: ISubNavigationState, action: IReduxAction<IReduxActionsPayload>) => ISubNavigationState;
	const subNavigationsReducer: (state: ISubNavigationState[], action: IReduxAction<IReduxActionsPayload>) => ISubNavigationState[];

}
declare module ReactVapor {
	interface ITabActionPayload {
	    groupId: string;
	    id: string;
	}
	const TabAction: {
	    selectTab: string;
	    addTab: string;
	    removeTab: string;
	};
	const selectTab: (id: string, groupId?: string) => IReduxAction<ITabActionPayload>;
	const addTab: (id: string, groupId?: string) => IReduxAction<ITabActionPayload>;
	const removeTab: (id: string, groupId?: string) => IReduxAction<ITabActionPayload>;

}
declare module ReactVapor {
	const DEFAULT_GROUP_ID: string;
	interface ITabState {
	    id: string;
	    isSelected: boolean;
	}
	interface ITabGroupState {
	    id: string;
	    tabs: ITabState[];
	}
	const tabInitialState: ITabState;
	const tabsInitialState: ITabState[];
	const tabGroupInitialState: ITabGroupState;
	const tabGroupsInitialState: ITabGroupState[];
	const tabReducer: (state: ITabState, action: IReduxAction<ITabActionPayload>) => ITabState;
	const tabsReducer: (state: ITabState[], action: IReduxAction<ITabActionPayload>) => ITabState[];
	const tabGroupReducer: (state: ITabGroupState, action: IReduxAction<ITabActionPayload>) => ITabGroupState;
	const tabGroupsReducer: (state: ITabGroupState[], action: IReduxAction<ITabActionPayload>) => ITabGroupState[];

}
declare module ReactVapor {
	const TextAreaActions: {
	    add: string;
	    remove: string;
	    changeValue: string;
	    setDisabled: string;
	};
	interface ITextAreaActionPayload {
	    id: string;
	    value?: string;
	    disabled?: boolean;
	}
	const addTextArea: (id: string, value?: string, disabled?: boolean) => IReduxAction<ITextAreaActionPayload>;
	const removeTextArea: (id: string) => IReduxAction<ITextAreaActionPayload>;
	const changeTextAreaValue: (id: string, value?: string) => IReduxAction<ITextAreaActionPayload>;
	const setDisabledTextArea: (id: string, disabled?: boolean) => IReduxAction<ITextAreaActionPayload>;

}
declare module ReactVapor {
	interface ITextAreaState {
	    id: string;
	    value: string;
	    disabled: boolean;
	}
	const textAreaInitialState: ITextAreaState;
	const textAreasInitialState: ITextAreaState[];
	const textAreasReducer: (state: ITextAreaState[], action: IReduxAction<ITextAreaActionPayload>) => ITextAreaState[];

}
declare module ReactVapor {
	interface IToastProps {
	    id?: string;
	    title?: string;
	    isOpened?: boolean;
	    type?: string;
	    dismiss?: number;
	    dismissible?: boolean;
	    animate?: boolean;
	    content?: ComponentContent;
	    onRender?: () => void;
	    onClose?: () => void;
	    onDestroy?: () => void;
	}
	const ToastType: {
	    Success: string;
	    Warning: string;
	    Error: string;
	};
	class Toast extends React.Component<IToastProps, {}> {
	    static defaultProps;
	    componentWillMount(): void;
	    componentDidMount(): void;
	    componentWillUnmount(): void;
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	interface IToastContainerActionPayload {
	    id: string;
	}
	interface IToastActionPayload {
	    containerId: string;
	    id?: string;
	}
	const ToastAction: {
	    addToast: string;
	    removeToast: string;
	    addToastContainer: string;
	    removeToastContainer: string;
	};
	interface IToastAddOptionalPayload {
	    dismiss?: number;
	    dismissible?: boolean;
	    type?: string;
	    animate?: boolean;
	    content?: ComponentContent;
	}
	interface IToastAddPayload extends IToastActionPayload, IToastAddOptionalPayload {
	    title: string;
	}
	const addToast: (containerId: string, title: string, optionals?: IToastAddOptionalPayload) => IReduxAction<IToastAddPayload>;
	const removeToast: (containerId: string, id: string) => IReduxAction<IToastActionPayload>;
	const addToastContainer: (id: string) => IReduxAction<IToastContainerActionPayload>;
	const removeToastContainer: (id: string) => IReduxAction<IToastContainerActionPayload>;

}
declare module ReactVapor {
	interface IToastsState {
	    id: string;
	    toasts: IToastState[];
	}
	interface IToastState {
	    id: string;
	    title: string;
	    type?: string;
	    dismiss?: number;
	    dismissible?: boolean;
	    animate?: boolean;
	    content?: ComponentContent;
	}
	const toastContainerInitialState: IToastsState;
	const toastInitialState: IToastState;
	const toastsContainerInitialState: IToastsState[];
	const toastContainerReducer: (state: IToastsState, action: IReduxAction<IToastContainerActionPayload>) => IToastsState;
	const toastsContainerReducer: (state: IToastsState[], action: IReduxAction<IToastContainerActionPayload>) => IToastsState[];

}
declare module ReactVapor {
	interface IReactVaporState {
	    autocompletes: IAutocompleteState[];
	    lastUpdatedComposite?: ILastUpdatedState[];
	    facets?: IFacetState[];
	    filters?: IFilterState[];
	    perPageComposite?: IPerPageState[];
	    paginationComposite?: IPaginationState[];
	    loadings?: ILoadingState[];
	    listBoxes?: IListBoxState[];
	    selects?: ISelectState[];
	    prompts?: IPromptState[];
	    actionBars?: IActionBarState[];
	    dropdowns?: IDropdownState[];
	    dropdownSearch?: IDropdownSearchState[];
	    flatSelect?: IFlatSelectState[];
	    rows?: ITableRowState[];
	    optionsCycles?: IOptionsCycleState[];
	    datePickers?: IDatePickerState[];
	    optionPickers?: IOptionPickerState[];
	    itemFilters?: IItemFilterState[];
	    modals?: IModalState[];
	    openModals?: string[];
	    subNavigations?: ISubNavigationState[];
	    tabs?: ITabGroupState[];
	    toastContainers?: IToastsState[];
	    tableHeaderCells?: ITableHeaderCellsState;
	    tables?: ITablesState;
	    checkboxes?: ICheckboxState[];
	    inputs?: IInputState[];
	    collapsibles?: CollapsibleState[];
	    searchBars?: ISearchBarState[];
	    flippables?: IFlippableState[];
	    groupableCheckboxes?: IGroupableCheckboxesState[];
	    textAreas?: ITextAreaState[];
	    menus?: IMenusState;
	}
	interface IReduxActionsPayload {
	    id?: string;
	    ids?: string[];
	    isCollapsible?: boolean;
	    facet?: string;
	    facetRow?: IFacet;
	    filterText?: string;
	    pageNb?: number;
	    perPage?: number;
	    options?: IInlinePromptOptions;
	    actions?: IActionOptions[];
	    currentOption?: number;
	    color?: string;
	    date?: Date;
	    calendarId?: string;
	    value?: string;
	    isRange?: boolean;
	    limit?: string;
	    item?: string;
	    label?: string;
	    selected?: string;
	    tableId?: string;
	    isInError?: boolean;
	    attributeToFormat?: string;
	    attributeToSort?: string;
	    initialTableData?: ITableData;
	    initialPerPage?: number;
	    tableStateModifier?: ITableStateModifier;
	    totalEntries?: number;
	    totalPages?: number;
	    addedSelectedOption?: IDropdownOption;
	    predicates?: ITablePredicate[];
	    shouldResetPage?: boolean;
	    valid?: boolean;
	    expanded?: boolean;
	    disabled?: boolean;
	    searching?: boolean;
	    yPosition?: number;
	}

}
declare module ReactVapor {
	const TriggerActionConnected: React.ComponentClass<ITriggerActionProps>;

}
declare module ReactVapor {
	interface IPrimaryActionOwnProps extends React.ClassAttributes<PrimaryAction>, IBasicActionProps {
	    parentId?: string;
	}
	interface IPrimaryActionStateProps extends IReduxStatePossibleProps {
	}
	interface IPrimaryActionProps extends IPrimaryActionOwnProps, IPrimaryActionStateProps {
	}
	class PrimaryAction extends React.Component<IPrimaryActionProps, any> {
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	const PrimaryActionConnected: React.ComponentClass<IPrimaryActionProps>;

}
declare module ReactVapor {
	interface IDropdownOwnProps extends React.ClassAttributes<Dropdown> {
	    id?: string;
	    toggleContent: JSX.Element[];
	    dropdownItems: JSX.Element[];
	    className?: string;
	}
	interface IDropdownStateProps {
	    isOpened?: boolean;
	}
	interface IDropdownDispatchProps {
	    onRender?: () => void;
	    onDestroy?: () => void;
	    onClick?: () => void;
	    onDocumentClick?: () => void;
	}
	interface IDropdownProps extends IDropdownOwnProps, IDropdownStateProps, IDropdownDispatchProps {
	}
	class Dropdown extends React.Component<IDropdownProps, any> {
	    componentWillMount(): void;
	    componentWillUnmount(): void;
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	const DropdownConnected: React.ComponentClass<IDropdownProps>;

}
declare module ReactVapor {
	interface IActionsDropdownOwnProps extends React.ClassAttributes<ActionsDropdown> {
	    actions: IActionOptions[];
	    id?: string;
	    moreLabel?: string;
	}
	interface IActionsDropdownStateProps extends IReduxStatePossibleProps {
	    isOpened?: boolean;
	}
	interface IActionsDropdownProps extends IActionsDropdownOwnProps, IActionsDropdownStateProps {
	}
	const MORE_LABEL: string;
	class ActionsDropdown extends React.Component<IActionsDropdownProps, any> {
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	const ActionsDropdownConnected: React.ComponentClass<IActionsDropdownProps>;

}
declare module ReactVapor {
	interface ISecondaryActionsOwnProps extends React.ClassAttributes<SecondaryActions> {
	    actions: IActionOptions[];
	    id?: string;
	}
	interface ISecondaryActionsStateProps extends IReduxStatePossibleProps {
	}
	interface ISecondaryActionChildrenProps {
	    moreLabel?: string;
	}
	interface ISecondaryActionsProps extends ISecondaryActionsOwnProps, ISecondaryActionsStateProps, ISecondaryActionChildrenProps {
	}
	class SecondaryActions extends React.Component<ISecondaryActionsProps, any> {
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	const SecondaryActionsConnected: React.ComponentClass<ISecondaryActionsProps>;

}
declare module ReactVapor {
	const DEFAULT_ACTIONS_CONTAINER_CLASSES: string[];
	interface IActionBarOwnProps extends React.ClassAttributes<ActionBar> {
	    id?: string;
	    itemFilterLabel?: string;
	    itemTooltipProps?: ITooltipProps;
	    onClearItemFilter?: () => void;
	    extraContainerClasses?: string[];
	    removeDefaultContainerClasses?: boolean;
	    withSmallActions?: boolean;
	    prefixContent?: IContentProps;
	    width?: number;
	}
	interface IActionBarStateProps extends IReduxStatePossibleProps {
	    actions?: IActionOptions[];
	    prompt?: JSX.Element;
	    itemFilter?: string;
	    isLoading?: boolean;
	}
	interface IActionBarDispatchProps {
	    onRender?: () => void;
	    onDestroy?: () => void;
	    clearItemFilter?: () => void;
	}
	interface IActionBarChildrenProps {
	    moreLabel?: string;
	    itemFilterCropLength?: number;
	}
	interface IActionBarProps extends IActionBarOwnProps, IActionBarStateProps, IActionBarDispatchProps, IActionBarChildrenProps {
	}
	class ActionBar extends React.Component<IActionBarProps, any> {
	    static defaultProps;
	    componentWillMount(): void;
	    componentWillUnmount(): void;
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	const MemberEditionActionsType: {
	    ApplyChanges: string;
	    CancelChanges: string;
	    ChangeEmail: string;
	    ChangeSendEmail: string;
	    ToggleOpen: string;
	};
	interface IMemberEditionActionPayload {
	    id: string;
	}
	interface IChangeEmailPayload extends IMemberEditionActionPayload {
	    email: string;
	}
	interface IChangeSendEmailPayload extends IMemberEditionActionPayload {
	    sendEmail: boolean;
	}
	interface IToggleOpenPayload extends IMemberEditionActionPayload {
	    isOpen: boolean;
	}
	interface IMemberEditionActionsPayloads extends IMemberEditionActionPayload, IChangeEmailPayload, IChangeSendEmailPayload, IToggleOpenPayload {
	}
	const applyChanges: (id: string) => IReduxAction<IMemberEditionActionPayload>;
	const cancelChanges: (id: string) => IReduxAction<IMemberEditionActionPayload>;
	const changeEmail: (id: string, email: string) => IReduxAction<IChangeEmailPayload>;
	const changeSendEmail: (id: string, sendEmail: boolean) => IReduxAction<IChangeSendEmailPayload>;
	const toggleOpen: (id: string, isOpen: boolean) => IReduxAction<IToggleOpenPayload>;

}
declare module ReactVapor {
	interface IMemberAttributes {
	    email?: string;
	    sendEmail?: boolean;
	}
	const defaultMemberAttributes: IMemberAttributes;

}
declare module ReactVapor {
	const MembersActionsType: {
	    SetMembers: string;
	    AddMember: string;
	};
	interface ISetMembersPayload {
	    members: IMemberAttributes[];
	}
	interface IMembersActionsPayloads extends IMemberEditionActionsPayloads, ISetMembersPayload {
	}
	const setMembers: (members: IMemberAttributes[]) => IReduxAction<ISetMembersPayload>;
	const addMember: () => IReduxAction<any>;

}
declare module ReactVapor {
	interface IMemberEditionState {
	    id: string;
	    appliedState: IMemberAttributes;
	    editionState: IMemberAttributes;
	    isOpen: boolean;
	}
	const defaultMemberEditionState: IMemberEditionState;
	const memberEditionReducers: (state: IMemberEditionState, action: IReduxAction<IMemberEditionActionsPayloads>) => IMemberEditionState;

}
declare module ReactVapor {
	interface IMembersCompositeState {
	    addMemberState: IMemberEditionState;
	    members: IMemberEditionState[];
	}
	const membersReducers: (state: IMembersCompositeState, action: IReduxAction<IMembersActionsPayloads>) => IMembersCompositeState;

}
declare module ReactVapor {
	const ReactVaporReducers: ReducersMapObject;

}
declare module ReactVapor {
	interface IReactVaporExampleState extends IReactVaporState {
	    membersCompositeState: IMembersCompositeState;
	    lastAction: Redux.Action;
	}
	const Reducers: Redux.Reducer<IReactVaporExampleState>;

}
declare module ReactVapor {
	const ReactVaporStore: Redux.Store<IReactVaporExampleState>;

}
declare module ReactVapor {
	type KeyValue<T> = {
	    [key: string]: T;
	};
	const mod: (x: number, n: number) => number;

}
declare module ReactVapor {
	interface IListBoxOwnProps {
	    items: IItemBoxProps[];
	    noResultItem?: IItemBoxProps;
	    classes?: string[];
	    id?: string;
	    multi?: boolean;
	    highlight?: string;
	}
	interface IListBoxStateProps {
	    selected?: string[];
	    active?: number;
	}
	interface IListBoxDispatchProps {
	    onRender?: () => void;
	    onDestroy?: () => void;
	    onOptionClick?: (option: IItemBoxProps) => void;
	}
	interface IListBoxProps extends IListBoxOwnProps, IListBoxStateProps, IListBoxDispatchProps {
	}
	class ListBox extends React.Component<IListBoxProps, {}> {
	    static defaultProps;
	    componentWillMount(): void;
	    componentWillUnmount(): void;
	    protected getItems(): JSX.Element[] | JSX.Element;
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	const ListBoxConnected: React.ComponentClass<IListBoxProps>;

}
declare module ReactVapor {
	interface IAutocompleteOwnProps {
	    id: string;
	    items: IItemBoxProps[];
	    inline?: boolean;
	    matchFilter?: (filterValue: string, item: IItemBoxProps) => boolean;
	}
	interface IAutocompleteStateProps {
	    isOpen?: boolean;
	    value?: string;
	    visibleItems?: IItemBoxProps[];
	    active?: number;
	}
	interface IAutocompleteDispatchProps {
	    onRender?: () => void;
	    onDestroy?: () => void;
	    onDocumentClick?: () => void;
	    onFocus?: () => void;
	    onValueChange?: (value: string, open: boolean) => void;
	    setActive?: (diff: number) => void;
	}
	interface IAutocompleteProps extends IAutocompleteOwnProps, IAutocompleteStateProps, IAutocompleteDispatchProps {
	}
	class AutocompleteConnected extends React.Component<IAutocompleteProps & React.HTMLProps<AutocompleteConnected>, {}> {
	    static defaultProps;
	    componentWillMount(): void;
	    componentWillUnmount(): void;
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	class UUID {
	    static generate(): string;
	}

}
declare module ReactVapor {
	const DEFAULT_BADGE_CLASSNAME = "badge";
	interface IBadgeProps {
	    label: string;
	    extraClasses?: string[];
	}
	class Badge extends React.Component<IBadgeProps> {
	    static defaultProps;
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	const borderedLine: string;

}
declare module ReactVapor {
	class BorderedLine extends React.PureComponent<React.HTMLAttributes<HTMLDivElement>> {
	    static defaultClassName: string;
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	interface ITitleProps extends React.ClassAttributes<Title> {
	    prefix?: string;
	    text: string;
	    withTitleTooltip?: boolean;
	    documentationLink?: ILinkSvgProps;
	    classes?: string[];
	}
	class Title extends React.Component<ITitleProps, {}> {
	    static defaultProps;
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	interface IBreadcrumbLinkProps {
	    name: string;
	    link?: string;
	    classes?: string;
	    onClick?: (props: IBreadcrumbLinkProps) => boolean;
	}
	class BreadcrumbLink extends React.Component<IBreadcrumbLinkProps, {}> {
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	interface IBreadcrumbProps extends React.ClassAttributes<Breadcrumb> {
	    links?: IBreadcrumbLinkProps[];
	    defaultLinkPath?: string;
	    title: ITitleProps;
	}
	class Breadcrumb extends React.Component<IBreadcrumbProps, {}> {
	    static defaultProps;
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	interface ITabOwnProps {
	    groupId?: string;
	    id?: string;
	    title: string;
	}
	interface ITabStateProps {
	    isActive?: boolean;
	}
	interface ITabDispatchProps {
	    onRender?: () => void;
	    onDestroy?: () => void;
	    onSelect?: () => void;
	}
	interface ITabProps extends ITabOwnProps, ITabStateProps, ITabDispatchProps {
	}
	class Tab extends React.Component<ITabProps, any> {
	    componentWillMount(): void;
	    componentWillUnmount(): void;
	    select(): void;
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	interface ICheckboxOwnProps {
	    handleOnClick?: (isChecked: boolean) => void;
	}
	interface ICheckboxStateProps {
	    defaultDisabled?: boolean;
	}
	interface ICheckboxProps extends ICheckboxOwnProps, ICheckboxStateProps, IInputProps {
	}
	class Checkbox extends React.Component<ICheckboxProps> {
	    componentDidMount(): void;
	    componentDidUpdate(): void;
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	/// <reference types="react" />
	interface IGroupableCheckboxOwnProps extends ICheckboxProps {
	    isParent?: boolean;
	    parentId?: string;
	}
	const GroupableCheckboxConnected: React.ComponentClass<IGroupableCheckboxOwnProps>;

}
declare module ReactVapor {
	/// <reference types="react" />
	const CheckboxConnected: React.ComponentClass<ICheckboxProps>;

}
declare module ReactVapor {
	class ValidComponentChildren {
	    static map(children: React.ReactNode, func: (child: React.ReactChild) => any, context: any): any[];
	}

}
declare module ReactVapor {
	interface IChildFormProps {
	    disabled?: boolean;
	}
	class ChildForm extends React.Component<IChildFormProps, any> {
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	interface IToggleFormProps {
	    classes?: string[];
	    checked?: boolean;
	    children?: React.ReactElement<Input | ChildForm> | Array<React.ReactElement<Input | ChildForm>>;
	    onClick?: (e) => void;
	    value?: string;
	}
	class ToggleForm extends React.Component<IToggleFormProps, any> {
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	/// <reference types="react" />
	class Radio extends Input {
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	interface IRadioSelectProps {
	    name?: string;
	    value?: string;
	    disabled?: boolean;
	    onChange?: (value: string) => void;
	    children?: Array<React.ReactElement<Radio>> | Array<React.ReactElement<ToggleForm>>;
	}
	class RadioSelect extends React.Component<IRadioSelectProps, any> {
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	/// <reference types="jquery" />
	interface IChosenSelectProps extends React.HTMLProps<ChosenSelect> {
	    allowSingleDeselect?: boolean;
	    caseSensitiveSearch?: boolean;
	    disableSearch?: boolean;
	    disableSearchThreshold?: number;
	    displayDisabledOptions?: boolean;
	    displaySelectedOptions?: boolean;
	    enableSplitWordSearch?: boolean;
	    includeGroupLabelInSelected?: boolean;
	    inheritSelectClasses?: boolean;
	    maxSelectedOptions?: number;
	    maxShownResults?: number;
	    noResultsText?: string;
	    onChosenChange?: (event: JQueryEventObject, args: Chosen.SelectedData) => void;
	    placeholderTextMultiple?: string;
	    placeholderTextSingle?: string;
	    searchContains?: boolean;
	    singleBackstrokeDelete?: boolean;
	    width?: string;
	}
	class ChosenSelect extends React.Component<IChosenSelectProps, any> {
	    select: JQuery;
	    componentDidMount(): void;
	    componentWillUnmount(): void;
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	interface CollapsibleOwnProps {
	    id: string;
	    expandedOnMount?: boolean;
	    headerContent?: React.ReactNode;
	    headerClasses?: string;
	    toggleIconClassName?: string;
	    className?: string;
	    withBorders?: boolean;
	}
	interface CollapsibleStateProps {
	    expanded?: boolean;
	}
	interface CollapsibleDispatchProps {
	    onMount?: () => void;
	    onUnmount?: () => void;
	    onToggleExpandedState?: (currentExpandedState: boolean) => void;
	}
	interface CollapsibleProps extends CollapsibleOwnProps, CollapsibleStateProps, CollapsibleDispatchProps {
	}
	class Collapsible extends React.Component<CollapsibleProps> {
	    static TIMEOUT: number;
	    componentWillMount(): void;
	    componentWillUnmount(): void;
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	const CollapsibleConnected: React.ComponentClass<CollapsibleProps>;

}
declare module ReactVapor {
	const collapsible: string;
	const header: string;
	const content: string;

}
declare module ReactVapor {
	interface ICollapsibleContainerOwnProps {
	    id: string;
	    title: JSXRenderable;
	    expandedOnMount?: boolean;
	    informationUrl?: string;
	    informationTooltip?: ITooltipProps;
	    className?: IClassName;
	    collapsibleHeaderClassName?: IClassName;
	    collapsibleBodyClassName?: IClassName;
	    withoutContentPadding?: boolean;
	}
	interface ICollapsibleContainerStateProps {
	    expanded?: boolean;
	}
	interface ICollapsibleContainerProps extends ICollapsibleContainerOwnProps, ICollapsibleContainerStateProps {
	}
	class CollapsibleContainer extends React.Component<ICollapsibleContainerProps> {
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	/// <reference types="react" />
	const CollapsibleContainerConnected: React.ComponentClass<ICollapsibleContainerProps>;

}
declare module ReactVapor {
	const roundedBorders: string;
	const alignWithIcon: string;

}
declare module ReactVapor {
	interface CollapsibleInfoBoxProps {
	    id: string;
	    title: string;
	    expandedOnMount?: boolean;
	}
	class CollapsibleInfoBox extends React.PureComponent<CollapsibleInfoBoxProps> {
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	{};

}
declare module ReactVapor {
	interface IColorBarProps {
	    widthPerColor: KeyValue<number>;
	    tooltipPerColor?: KeyValue<ITooltipProps>;
	    height?: string;
	    className?: IClassName;
	}
	class ColorBar extends React.Component<IColorBarProps> {
	    static defaultProps;
	    render(): JSX.Element;
	    getAdjustedWidthPerColor(): KeyValue<number>;
	}

}
declare module ReactVapor {
	const DEFAULT_CORNER_RIBBON_CLASSNAME = "corner-ribbon";
	const DEFAULT_CORNER_RIBBON_CONTAINER_CLASSNAME = "ribbon-container";
	enum PlacementY {
	    Top = "top",
	    Bottom = "bottom"
	}
	enum PlacementX {
	    Left = "left",
	    Right = "right"
	}
	interface ICornerRibbonProps {
	    label?: string;
	    placementY?: PlacementY;
	    placementX?: PlacementX;
	    extraClasses?: string[];
	}
	class CornerRibbon extends React.Component<ICornerRibbonProps> {
	    static defaultProps;
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	const diffViewer: string;

}
declare module ReactVapor {
	interface DiffViewerProps extends React.ClassAttributes<DiffViewer> {
	    first: string;
	    second: string;
	}
	class DiffViewer extends React.Component<DiffViewerProps> {
	    static OutputFormat: {
	        Side: string;
	        Line: string;
	    };
	    static InputFormat: {
	        Diff: string;
	        JSON: string;
	    };
	    static Matching: {
	        Lines: string;
	        Words: string;
	        None: string;
	    };
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	const fakeJSON: {
	    _id: string;
	    index: number;
	    guid: string;
	    isActive: boolean;
	    balance: string;
	    picture: string;
	    age: number;
	    eyeColor: string;
	    name: {
	        first: string;
	        last: string;
	    };
	    company: string;
	    email: string;
	    phone: string;
	    address: string;
	    about: string;
	    registered: string;
	    latitude: string;
	    longitude: string;
	    tags: string[];
	    range: number[];
	    friends: {
	        id: number;
	        name: string;
	    }[];
	    greeting: string;
	    favoriteFruit: string;
	};
	const fakeJSON1: {
	    [key: string]: any;
	};
	const JSONToString: (json: {
	    [key: string]: any;
	}) => string;

}
declare module ReactVapor {
	interface ISelectedOptionProps {
	    value: string;
	    label: React.ReactNode;
	    onRemoveClick?: (value: string) => void;
	    key: string;
	}
	class SelectedOption extends React.Component<ISelectedOptionProps, any> {
	    handleOnRemove(): void;
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	interface IDraggableSelectedOptionOwnProps {
	    isDragging?: boolean;
	    connectDragSource?: any;
	    connectDropTarget?: any;
	    connectDragPreview?: any;
	    index: number;
	    move: (dragIndex: number, hoverIndex: number) => void;
	}
	interface IDraggableSelectedOptionProps extends IDraggableSelectedOptionOwnProps, ISelectedOptionProps {
	}
	const DraggableSelectedOptionType = "SELECTED_OPTION";
	class DraggableSelectedOption extends React.Component<IDraggableSelectedOptionProps> {
	    render(): any;
	}

}
declare module ReactVapor {
	interface IMultiselectInputProps {
	    selectedOptions: IDropdownOption[];
	    onRemoveClick?: (value: string) => void;
	    onRemoveAll?: () => void;
	    onFilterTextChange?: (filterText: string) => void;
	    onBlur?: () => void;
	    onFocus?: () => void;
	    onKeyDownFilterBox?: (e) => void;
	    filterPlaceholder?: string;
	    filterText?: string;
	    deselectAllTooltipText?: string;
	}
	class MultiselectInput extends React.Component<IMultiselectInputProps, any> {
	    static defaultProps;
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	/// <reference types="react" />
	interface IMultiSelectDropdownSearchProps extends IDropdownSearchProps {
	    displayedOptions: IDropdownOption[];
	    selectedOptions: IDropdownOption[];
	}
	class MultiSelectDropdownSearch extends DropdownSearch {
	    static defaultProps;
	    protected getNoOptions(): JSX.Element[];
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	/// <reference types="react" />
	const MultiSelectDropdownSearchConnected: React.ComponentClass<IDropdownSearchProps>;

}
declare module ReactVapor {
	const CodeMirrorGutters: {
	    LineNumbers: string;
	    FoldGutter: string;
	    LintMarkers: string;
	};
	const CodeMirrorModes: {
	    JSON: string;
	    XML: string;
	    Python: string;
	};

}
declare module ReactVapor {
	interface ICodeEditorProps {
	    value: string;
	    readOnly?: boolean;
	    onChange?: (code: string) => void;
	    onMount?: (codemirror: ReactCodeMirror.UnControlled) => void;
	    errorMessage?: string;
	    mode: any;
	    extraKeywords?: string[];
	    className?: string;
	}
	class CodeEditor extends React.Component<ICodeEditorProps> {
	    static defaultProps;
	    static Options: CodeMirror.EditorConfiguration;
	    componentDidMount(): void;
	    componentDidUpdate(prevProps: ICodeEditorProps): void;
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	interface IJSONEditorProps {
	    value: string;
	    readOnly?: boolean;
	    onChange?: (json: string, inError: boolean) => void;
	    errorMessage?: string;
	}
	interface IJSONEditorState {
	    isInError: boolean;
	}
	const DEFAULT_JSON_ERROR_MESSAGE: string;
	class JSONEditor extends React.Component<IJSONEditorProps, IJSONEditorState> {
	    static defaultProps;
	    constructor(props: IJSONEditorProps, state: IJSONEditorState);
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	const FacetConnected: React.ComponentClass<IFacetProps>;

}
declare module ReactVapor {
	interface IFlatSelectOptionProps {
	    id: string;
	    option: IContentProps;
	    classes?: string[];
	    prepend?: IContentProps;
	    append?: IContentProps;
	    tooltip?: ITooltipProps;
	    selected?: boolean;
	    onClick?: (option: IFlatSelectOptionProps) => void;
	}
	class FlatSelectOption extends React.Component<IFlatSelectOptionProps, any> {
	    static defaultProps;
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	interface IFlatSelectOwnProps {
	    id: string;
	    options: IFlatSelectOptionProps[];
	    classes?: string[];
	    group?: boolean;
	    optionPicker?: boolean;
	    defaultSelectedOptionId?: string;
	    onClick?: (option: IFlatSelectOptionProps) => void;
	}
	interface IFlatSelectStateProps {
	    selectedOptionId?: string;
	}
	interface IFlatSelectDispatchProps {
	    onRender?: () => void;
	    onDestroy?: () => void;
	    onOptionClick?: (option: IFlatSelectOptionProps) => void;
	}
	interface IFlatSelectProps extends IFlatSelectOwnProps, IFlatSelectStateProps, IFlatSelectDispatchProps {
	}
	class FlatSelect extends React.Component<IFlatSelectProps> {
	    componentWillMount(): void;
	    componentWillUnmount(): void;
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	const FlatSelectConnected: React.ComponentClass<IFlatSelectProps>;

}
declare module ReactVapor {
	interface IFlippableOwnProps {
	    id?: string;
	    front?: React.ReactNode;
	    back?: React.ReactNode;
	    className?: string;
	    allowUnflip?: (e: EventTarget) => boolean;
	}
	interface IFlippableDispatchProps {
	    onRender?: () => void;
	    onDestroy?: () => void;
	    onFlip?: () => void;
	    onUnflip?: () => void;
	}
	interface IFlippableStateProps {
	    isFlipped?: boolean;
	}
	interface IFlippableProps extends IFlippableOwnProps, IFlippableDispatchProps, IFlippableStateProps {
	}
	class Flippable extends React.Component<IFlippableProps & React.HTMLProps<HTMLDivElement>, any> {
	    static CONTAINER_CLASSNAME: string;
	    static FLIPPER_CLASSNAME: string;
	    static sides: {
	        FRONT: string;
	        BACK: string;
	    };
	    static triggers: {
	        FRONT: string;
	        BACK: string;
	    };
	    static defaults;
	    componentWillMount(): void;
	    componentWillUnmount(): void;
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	/// <reference types="react" />
	const FlippableConnected: React.ComponentClass<IFlippableProps>;

}
declare module ReactVapor {
	/// <reference types="react" />
	const TabConnected: React.ComponentClass<ITabProps>;

}
declare module ReactVapor {
	interface ITabNavigationProps {
	}
	class TabNavigation extends React.Component<ITabNavigationProps, any> {
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	interface ITabsHeaderProps extends React.ClassAttributes<React.Component<any, any>> {
	    tabs?: ITabProps[];
	}
	const TabsHeader: (props: ITabsHeaderProps) => JSX.Element;

}
declare module ReactVapor {
	interface IHeaderWrapperProps extends ITabsHeaderProps, React.ClassAttributes<React.Component<any, any>> {
	    description?: string;
	    actions?: IContentProps[];
	    classes?: string[];
	    hasBorderBottom?: boolean;
	    hasPadding?: boolean;
	}
	class HeaderWrapper extends React.Component<IHeaderWrapperProps, {}> {
	    static defaultProps;
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	interface IBasicHeaderProps extends IHeaderWrapperProps, React.ClassAttributes<React.Component<any, any>> {
	    title: ITitleProps;
	}
	class BasicHeader extends React.Component<IBasicHeaderProps, {}> {
	    static defaultProps;
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	interface IBreadcrumbHeaderProps extends IHeaderWrapperProps, React.ClassAttributes<React.Component<any, any>> {
	    breadcrumb: IBreadcrumbProps;
	}
	class BreadcrumbHeader extends React.Component<IBreadcrumbHeaderProps, {}> {
	    static defaultProps;
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	/// <reference types="react" />
	const InputConnected: React.ComponentClass<IInputProps>;

}
declare module ReactVapor {
	enum TooltipPlacement {
	    Top = "top",
	    Bottom = "bottom",
	    Left = "left",
	    Right = "right"
	}

}
declare module ReactVapor {
	interface ILabeledValueProps {
	    label: string;
	    value: React.ReactNode;
	    fullRow?: true;
	    information?: string;
	    informationPlacement?: TooltipPlacement;
	    padding?: boolean;
	    className?: string;
	}
	class LabeledValue extends React.PureComponent<ILabeledValueProps> {
	    static defaultProps;
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	const DEFAULT_LOGO_CARD_CLASSNAME: string;
	const DEFAULT_LOGO_ICON: string;
	const DEFAULT_LOGO_ICON_CLASSNAME: string;
	const DEFAULT_LOGO_ICON_SIZE: string;
	const DEFAULT_DISABLED_RIBBON_LABEL: string;
	interface ILogoCardProps {
	    badges?: IBadgeProps[];
	    description?: string;
	    disabled?: boolean;
	    disabledRibbon?: ICornerRibbonProps;
	    extraContainerClasses?: string[];
	    onClick?: () => void;
	    ribbon?: ICornerRibbonProps;
	    svgName?: string;
	    title: string;
	}
	class LogoCard extends React.Component<ILogoCardProps & React.HTMLProps<HTMLDivElement>> {
	    static defaultProps;
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	interface IMenuOwnProps {
	    listBox: IListBoxProps;
	    className?: string;
	    id: string;
	    positionRight?: boolean;
	}
	interface IMenuStateProps {
	    isOpen?: boolean;
	    list?: IItemBoxProps[];
	}
	interface IMenuDispatchProps {
	    onRender?: () => void;
	    onDestroy?: () => void;
	    onToggleMenu?: () => void;
	    onDocumentClick?: () => void;
	}
	interface IMenuProps extends IMenuOwnProps, IMenuStateProps, IMenuDispatchProps {
	}
	class MenuConnected extends React.Component<IMenuProps, {}> {
	    static defaultProps;
	    componentWillMount(): void;
	    componentWillUnmount(): void;
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	interface IModalOwnProps {
	    id?: string;
	    classes?: IClassName;
	    closeCallback?: () => void;
	    closeTimeout?: number;
	}
	interface IModalStateProps {
	    isOpened?: boolean;
	}
	interface IModalDispatchProps {
	    onDestroy?: () => void;
	    onRender?: () => void;
	}
	interface IModalProps extends IModalOwnProps, IModalStateProps, IModalDispatchProps {
	}
	class Modal extends React.Component<IModalProps, {}> {
	    componentWillMount(): void;
	    componentWillUnmount(): void;
	    componentWillReceiveProps(nextProps: IModalProps): void;
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	interface IModalBackdropOwnProps {
	    displayFor?: string[];
	    isPrompt?: boolean;
	}
	interface IModalBackdropStateProps {
	    display?: boolean;
	    lastOpened?: boolean;
	}
	interface IModalBackdropDispatchProps {
	    onClick?: (id?: string) => void;
	}
	interface IModalBackdropProps extends IModalBackdropOwnProps, IModalBackdropStateProps, IModalBackdropDispatchProps {
	}
	class ModalBackdrop extends React.Component<IModalBackdropProps, {}> {
	    static defaultProps;
	    componentDidMount(): void;
	    componentDidUpdate(): void;
	    componentWillUnmount(): void;
	    handleClick(): void;
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	/// <reference types="react" />
	const ModalBackdropConnected: React.ComponentClass<IModalBackdropProps>;

}
declare module ReactVapor {
	interface IModalBodyProps {
	    classes?: IClassName;
	}
	class ModalBody extends React.Component<IModalBodyProps, {}> {
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	/// <reference types="react" />
	const ModalConnected: React.ComponentClass<IModalProps>;

}
declare module ReactVapor {
	interface IModalHeaderOwnProps {
	    id?: string;
	    title: string;
	    classes?: IClassName;
	}
	interface IModalHeaderStateProps {
	    lastOpened?: boolean;
	}
	interface IModalHeaderDispatchProps {
	    onClose?: () => void;
	}
	interface IModalHeaderProps extends IModalHeaderOwnProps, IModalHeaderStateProps, IModalHeaderDispatchProps {
	}
	class ModalHeader extends React.Component<IModalHeaderProps, {}> {
	    static defaultProps;
	    componentDidMount(): void;
	    componentDidUpdate(): void;
	    close(): void;
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	/// <reference types="react" />
	const ModalHeaderConnected: React.ComponentClass<IModalHeaderProps>;

}
declare module ReactVapor {
	interface IModalCompositeOwnProps extends IModalProps, IModalHeaderProps, IModalFooterProps, IModalBackdropProps {
	    modalHeaderChildren?: JSXRenderable;
	    modalHeaderClasses?: IClassName;
	    modalBodyChildren?: JSXRenderable;
	    modalBodyClasses?: IClassName;
	    modalFooterChildren?: JSXRenderable;
	    modalFooterClasses?: IClassName;
	    isPrompt?: boolean;
	}
	interface IModalCompositeStateProps extends IReduxStatePossibleProps {
	}
	interface IModalCompositeDispatchProps {
	}
	interface IModalCompositeProps extends IModalCompositeOwnProps, IModalCompositeStateProps, IModalCompositeDispatchProps {
	}
	class ModalComposite extends React.Component<IModalCompositeProps> {
	    static defaultProps;
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	/// <reference types="react" />
	const ModalCompositeConnected: React.ComponentClass<IModalCompositeProps>;

}
declare module ReactVapor {
	interface IModalPromptOwnProps {
	    id: string;
	    title: string;
	    message: string;
	    confirmLabel?: string;
	    cancelLabel?: string;
	}
	interface IModalPromptStateProps {
	    isOpened?: boolean;
	}
	interface IModalPromptDispatchProps {
	    onCancel?: (id: string) => void;
	    onDestroy?: (id: string) => void;
	    onRender?: (id: string) => void;
	    onConfirm: (id: string) => void;
	}
	const DEFAULT_MODAL_PROMPT_CONFIRM_LABEL: string;
	const DEFAULT_MODAL_PROMPT_CANCEL_LABEL: string;
	interface IModalPromptProps extends IModalPromptOwnProps, IModalPromptStateProps, IModalPromptDispatchProps {
	}
	class ModalPrompt extends React.Component<IModalPromptProps, any> {
	    static defaultProps;
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	/// <reference types="react" />
	enum MultiStepState {
	    ToDo = "to-do",
	    Doing = "doing",
	    Done = "done",
	    Error = "error",
	    Warning = "warning"
	}
	interface IStep {
	    state: MultiStepState;
	    text?: string;
	    tooltip?: ITooltipProps;
	}
	interface IMultiStepBarProps {
	    steps: IStep[];
	    className?: IClassName;
	    small?: boolean;
	    separator?: boolean;
	    inProgressAnimation?: '' | 'slide' | 'shine';
	    barAnimation?: '' | 'flare';
	}
	const MultiStepBar: (props: IMultiStepBarProps) => JSX.Element;

}
declare module ReactVapor {
	interface IAddInputActionProps {
	    title?: string;
	    onClick?: () => void;
	}
	class AddInputAction extends React.Component<IAddInputActionProps, any> {
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	class AddInput extends React.Component<IInputProps, any> {
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	interface IDeleteInputActionProps {
	    title?: string;
	    onClick: () => void;
	}
	class DeleteInputAction extends React.Component<IDeleteInputActionProps, any> {
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	class DeletableInput extends React.Component<IInputProps, any> {
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	interface IMultilineInputValue {
	    id: string;
	    value: string;
	}
	interface IMultilineInputOwnProps {
	    id?: string;
	    placeholder?: string;
	    title?: string;
	}
	interface IMultilineInputStateProps {
	    values?: IMultilineInputValue[];
	}
	interface IMultilineInputDispatchProps {
	    onChange?: (values: IMultilineInputValue[]) => void;
	}
	interface IMultilineInputProps extends IMultilineInputOwnProps, IMultilineInputStateProps, IMultilineInputDispatchProps {
	}
	class MultilineInput extends React.Component<IMultilineInputProps, any> {
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	const inputBlock: string;
	const input: string;

}
declare module ReactVapor {
	interface ISplitInput {
	    id: string;
	    label: string;
	    placeholder?: string;
	    validation?: (value: any) => boolean;
	    validationMessage?: string;
	}
	interface ISplitValue {
	    [inputId: string]: any;
	}
	interface ISplitMultilineInputOwnProps {
	    inputs: ISplitInput[];
	    defaultValues: ISplitValue[];
	    onChange?: (values: ISplitValue[]) => void;
	}
	interface ISplitMultilineInputProps extends ISplitMultilineInputOwnProps {
	}
	interface ISplitMultilineInputState {
	    values: ISplitValue[];
	}
	class SplitMultilineInput extends React.PureComponent<ISplitMultilineInputProps, ISplitMultilineInputState> {
	    static inputLineClass: string;
	    constructor(props: ISplitMultilineInputProps, state: ISplitMultilineInputState);
	    componentDidUpdate(prevProps: ISplitMultilineInputProps): void;
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	interface ITetherComponentCopiedProps {
	    renderElementTag?: string;
	    renderElementTo?: Element | string;
	    attachment: string;
	    targetAttachment?: string;
	    offset?: string;
	    targetOffset?: string;
	    targetModifier?: string;
	    enabled?: boolean;
	    classes?: any;
	    style?: {
	        [key: string]: any;
	    };
	    classPrefix?: string;
	    optimizations?: {
	        [key: string]: any;
	    };
	    constraints?: any[];
	    onUpdate?: (...args: any[]) => void;
	    onRepositioned?: (...args: any[]) => void;
	}
	interface IPopoverProps extends ITetherComponentCopiedProps, React.ClassAttributes<Popover> {
	    isOpen?: boolean;
	    onToggle?: (isOpen: boolean) => void;
	    isModal?: boolean;
	}
	interface IPopoverState {
	    isOpen: boolean;
	}
	class Popover extends React.Component<IPopoverProps, IPopoverState> {
	    constructor(props: IPopoverProps, state: IPopoverState);
	    componentDidMount(): void;
	    componentWillUnmount(): void;
	    render(): JSX.Element;
	    toggleOpened(isOpen: boolean): void;
	}

}
declare module ReactVapor {
	interface ISearchBarConnectedProps {
	    disabledOnMount?: boolean;
	}
	interface ISearchBarOwnProps extends ISearchBarConnectedProps {
	    id: string;
	    onSearch: (filterText: string) => void;
	    containerClassNames?: IClassName;
	    inputClassNames?: IClassName;
	    placeholder?: string;
	    minWidth?: string;
	    maxWidth?: string;
	}
	interface ISearchBarStateProps {
	    disabled?: boolean;
	    searching?: boolean;
	    value?: string;
	}
	interface ISearchBarDispatchProps {
	    onMount?: () => void;
	    onUnmount?: () => void;
	    onChange?: (event: React.ChangeEvent<HTMLInputElement>) => void;
	}
	interface ISearchBarProps extends ISearchBarOwnProps, ISearchBarStateProps, ISearchBarDispatchProps {
	}
	class SearchBar extends React.Component<ISearchBarProps> {
	    static defaultProps;
	    componentWillMount(): void;
	    componentWillUnmount(): void;
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	const SearchBarConnected: React.ComponentClass<ISearchBarProps>;

}
declare module ReactVapor {
	interface ISelectSpecificProps {
	    button: ComponentContent;
	    multi?: boolean;
	}
	interface ISelectOwnProps {
	    id: string;
	    placeholder?: string;
	}
	interface ISelectStateProps {
	    items?: IItemBoxProps[];
	    isOpen?: boolean;
	    active?: number;
	    selectedValues?: string[];
	    selectedLength?: number;
	}
	interface ISelectDispatchProps {
	    onRender?: () => void;
	    onDestroy?: () => void;
	    onDocumentClick?: () => void;
	    onToggleDropdown?: () => void;
	    onSelectValue?: (value: string, isMulti: boolean) => void;
	    setActive?: (diff: number) => void;
	}
	interface ISelectButtonProps {
	    onMouseUp: (e) => void;
	    onKeyUp: (e) => void;
	    onKeyDown: (e) => void;
	    placeholder?: string;
	}
	interface ISelectProps extends ISelectOwnProps, ISelectStateProps, ISelectDispatchProps {
	}
	class SelectConnected extends React.Component<ISelectProps & ISelectSpecificProps, {}> {
	    componentWillMount(): void;
	    componentWillUnmount(): void;
	    componentWillUpdate(nextProps: ISelectProps): any;
	    componentDidUpdate(prevProps: ISelectProps, prevState: null, snapshot: any): void;
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	interface IMultiSelectOwnProps extends ISelectProps, IDropTargetProps {
	    placeholder?: string;
	    emptyPlaceholder?: string;
	    deselectAllTooltipText?: string;
	    sortable?: boolean;
	}
	interface IMultiSelectStateProps {
	    selected?: string[];
	}
	interface IMultiSelectDispatchProps {
	    onRemoveClick?: (item: IItemBoxProps) => void;
	    onRemoveAll?: () => void;
	    onReorder?: (values: string[]) => void;
	}
	interface IMultiSelectProps extends IMultiSelectOwnProps, IMultiSelectStateProps, IMultiSelectDispatchProps {
	}
	class MultiSelectConnected extends React.Component<IMultiSelectProps, {}> {
	    static defaultProps;
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	interface ISelectWithFilterOwnProps {
	    matchFilter?: (filterValue: string, item: IItemBoxProps) => boolean;
	}
	interface ISelectWithFilterProps extends ISelectWithFilterOwnProps, ISelectProps {
	}
	const selectWithFilter: (Component: React.ComponentClass<ISelectWithFilterProps> | React.StatelessComponent<ISelectWithFilterProps>) => React.ComponentClass<ISelectWithFilterProps>;

}
declare module ReactVapor {
	interface ISelectWithPredicateOwnProps {
	    options: IFlatSelectOptionProps[];
	    matchPredicate: (predicate: string, item: IItemBoxProps) => boolean;
	}
	interface ISelectWithPredicateProps extends ISelectWithPredicateOwnProps, ISelectProps {
	}
	const selectWithPredicate: (Component: React.ComponentClass<ISelectProps> | React.StatelessComponent<ISelectProps>) => React.ComponentClass<ISelectWithPredicateProps>;

}
declare module ReactVapor {
	interface ISingleSelectOwnProps extends ISelectProps {
	    placeholder?: string;
	    toggleClasses?: string;
	    onSelectOptionCallback?: (option: string) => void;
	    items?: IItemBoxProps[];
	}
	interface ISingleSelectStateProps {
	    selectedOption?: string;
	}
	interface ISingleSelectDispatchProps {
	}
	interface ISingleSelectProps extends ISingleSelectOwnProps, ISingleSelectStateProps, ISingleSelectDispatchProps {
	}
	class SingleSelectConnected extends React.Component<ISingleSelectProps & React.HTMLProps<HTMLButtonElement>, {}> {
	    static defaultProps;
	    componentDidUpdate(prevProps: ISingleSelectProps): void;
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	interface ISelectWithPredicateAndFilterProps extends ISelectWithFilterProps, ISelectWithPredicateProps {
	}
	const SingleSelectWithFilter: React.ComponentClass<ISelectWithFilterProps & ISingleSelectOwnProps>;
	const SingleSelectWithPredicate: React.ComponentClass<ISelectWithPredicateProps & ISingleSelectOwnProps>;
	const SingleSelectWithPredicateAndFilter: React.ComponentClass<ISelectWithPredicateAndFilterProps & ISingleSelectOwnProps>;
	const MultiSelectWithFilter: React.ComponentClass<ISelectWithFilterProps & IMultiSelectOwnProps>;
	const MultiSelectWithPredicate: React.ComponentClass<ISelectWithPredicateProps & IMultiSelectOwnProps>;
	const MultiSelectWithPredicateAndFilter: React.ComponentClass<ISelectWithPredicateAndFilterProps & IMultiSelectOwnProps>;

}
declare module ReactVapor {
	/// <reference types="react" />
	interface ISideNavProps {
	    className?: string;
	    children?: JSXRenderable;
	}
	const SideNavigation: (props: ISideNavProps) => JSX.Element;

}
declare module ReactVapor {
	interface ISideNavigationHeaderProps {
	    title: string;
	    svgName?: string;
	    svgClass?: string;
	}
	class SideNavigationHeader extends React.Component<ISideNavigationHeaderProps> {
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	/// <reference types="react" />
	interface ISideNavigationItemProps {
	    href: string;
	    title: string;
	    target?: string;
	}
	const SideNavigationItem: (props: ISideNavigationItemProps) => JSX.Element;

}
declare module ReactVapor {
	/// <reference types="react" />
	const SideNavigationLoadingHeader: () => JSX.Element;

}
declare module ReactVapor {
	/// <reference types="react" />
	interface ISideNavLoadingItemProps {
	    className?: string;
	}
	const SideNavigationLoadingItem: (props: ISideNavLoadingItemProps) => JSX.Element;

}
declare module ReactVapor {
	interface ISideNavigationSectionOwnProps {
	    header?: ISideNavigationHeaderProps;
	    expandable?: boolean;
	}
	interface ISideNavigationSectionStateProps {
	    expanded?: boolean;
	}
	interface ISideNavigationSectionDispatchProps {
	    onClick?: () => void;
	}
	interface ISideNavigationSectionProps extends ISideNavigationSectionOwnProps, ISideNavigationSectionStateProps, ISideNavigationSectionDispatchProps {
	}
	class SideNavigationMenuSection extends React.Component<ISideNavigationSectionProps> {
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	interface ISliderProps {
	    slider?: SliderProps;
	    classes?: string[];
	    hasTooltip?: boolean;
	}
	class Slider extends React.Component<ISliderProps, {}> {
	    static defaultProps;
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	/// <reference types="react" />
	interface ISplitLayoutProps {
	    leftChildren?: JSXRenderable;
	    rightChildren?: JSXRenderable;
	    className?: string | string[];
	    leftContainerClassName?: string | string[];
	    rightContainerClassName?: string | string[];
	}
	const SplitLayout: (props: ISplitLayoutProps) => JSX.Element;

}
declare module ReactVapor {
	/// <reference types="react" />
	interface IStepProgressBarProps {
	    numberOfSteps: number;
	    currentStep: number;
	    className?: IClassName;
	}
	const StepProgressBar: (props: IStepProgressBarProps) => JSX.Element;

}
declare module ReactVapor {
	interface ISubNavigationOwnProps extends React.ClassAttributes<SubNavigation> {
	    id?: string;
	    items: ISubNavigationItem[];
	    defaultSelected?: string;
	}
	interface ISubNavigationStateProps {
	    selected?: string;
	}
	interface ISubNavigationDispatchProps {
	    onRender?: () => void;
	    onDestroy?: () => void;
	    onClickItem?: (id: string) => void;
	}
	interface ISubNavigationItem {
	    id: string;
	    label: string;
	    link?: string;
	}
	interface ISubNavigationProps extends ISubNavigationOwnProps, ISubNavigationStateProps, ISubNavigationDispatchProps {
	}
	class SubNavigation extends React.Component<ISubNavigationProps, any> {
	    componentWillMount(): void;
	    componentWillUnmount(): void;
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	const SubNavigationConnected: React.ComponentClass<ISubNavigationProps>;

}
declare module ReactVapor {
	interface ISyncFeedbackProps {
	    feedback?: string;
	    state: string;
	}
	const SyncFeedbackState: {
	    SYNCING: string;
	    SUCCESS: string;
	    ERROR: string;
	    NONE: string;
	};
	const DEFAULT_SYNC_FEEDBACK_SYNCING_LABEL: string;
	const DEFAULT_SYNC_FEEDBACK_SUCCESS_LABEL: string;
	const DEFAULT_SYNC_FEEDBACK_ERROR_LABEL: string;
	class SyncFeedback extends React.Component<ISyncFeedbackProps, any> {
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	interface ITabContentProps {
	}
	class TabContent extends React.Component<ITabContentProps, any> {
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	interface ITabPaneOwnProps {
	    groupId?: string;
	    id?: string;
	    className?: IClassName;
	}
	interface ITabPaneStateProps {
	    isActive?: boolean;
	}
	interface ITabPaneDispatchProps {
	}
	interface ITabPaneProps extends ITabPaneOwnProps, ITabPaneStateProps, ITabPaneDispatchProps {
	}
	class TabPane extends React.Component<ITabPaneProps, any> {
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	/// <reference types="react" />
	const TabPaneConnected: React.ComponentClass<ITabPaneProps>;

}
declare module ReactVapor {
	const dispatchPreTableStateModification: (tableId: string, dispatch: IDispatch) => void;
	const dispatchPostTableStateModification: (tableId: string, dispatch: IDispatch) => void;
	const applyPredicatesOnDisplayedIds: (nextDisplayedIds: string[], tableDataById: ITableRowData, tableCompositeState: ITableCompositeState) => string[];
	const applyFilterOnDisplayedIds: (nextDisplayedIds: string[], tableDataById: ITableRowData, tableCompositeState: ITableCompositeState, tableOwnProps: ITableOwnProps) => string[];
	const applyDatePickerOnDisplayedIds: (nextDisplayedIds: string[], tableDataById: ITableRowData, tableCompositeState: ITableCompositeState, tableOwnProps: ITableOwnProps) => string[];
	const applySortOnDisplayedIds: (nextDisplayedIds: string[], tableDataById: ITableRowData, tableCompositeState: ITableCompositeState, tableOwnProps: ITableOwnProps) => string[];
	const applyPaginationOnDisplayedIds: (nextDisplayedIds: string[], tableCompositeState: ITableCompositeState) => string[];
	const defaultTableStateModifier: (tableOwnProps: ITableOwnProps, tableCompositeState: ITableCompositeState) => ITableStateModifier;
	const defaultTableStateModifierThunk: (tableOwnProps: ITableOwnProps, shouldResetPage: boolean, tableCompositeState: ITableCompositeState) => (dispatch: IDispatch) => void;

}
declare module ReactVapor {
	const getTableCompositeState: (state: IReactVaporState, id: string) => ITableCompositeState;
	const TableConnected: React.ComponentClass<ITableProps>;

}
declare module ReactVapor {
	interface ITableEmptyRowProps extends React.ClassAttributes<TableEmptyRow> {
	    text: string;
	    nbColumns: number;
	}
	class TableEmptyRow extends React.Component<ITableEmptyRowProps, any> {
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	const tableOwnPropsMock: ITableProps;
	const tablePropsMock: ITableProps;
	const predictableData: IData;
	const dataById: {
	    [x: number]: {
	        [x: string]: any;
	        id: string;
	    };
	};
	const tablePropsMockWithData: any;
	const tablePossibleProps: any;

}
declare module ReactVapor {
	interface ITextAreaOwnProps {
	    id: string;
	    className?: string;
	    additionalAttributes?: React.DetailedHTMLProps<React.TextareaHTMLAttributes<HTMLTextAreaElement>, HTMLTextAreaElement>;
	    valueOnMount?: string;
	    disabledOnMount?: boolean;
	}
	interface ITextAreaStateProps {
	    value?: string;
	    disabled?: boolean;
	}
	interface ITextAreaDispatchProps {
	    onChange?: React.ChangeEventHandler<HTMLTextAreaElement>;
	    onMount?: () => void;
	    onUnmount?: () => void;
	}
	interface ITextAreaProps extends ITextAreaOwnProps, ITextAreaStateProps, ITextAreaDispatchProps {
	}
	class TextArea extends React.Component<ITextAreaProps, {}> {
	    static defaultProps;
	    componentWillMount(): void;
	    componentWillUnmount(): void;
	    render(): JSX.Element;
	}
	const TextAreaConnected: React.ComponentClass<ITextAreaProps>;

}
declare module ReactVapor {
	interface ITextAreaLabelProps {
	    children: React.ReactElement<ITextAreaProps>;
	    label: string;
	    containerClassName?: string;
	}
	const TextAreaLabel: (props: ITextAreaLabelProps) => JSX.Element;

}
declare module ReactVapor {
	interface IToastContainerOwnProps {
	    id?: string;
	    classes?: string[];
	    bottom?: boolean;
	    left?: boolean;
	    right?: boolean;
	}
	interface IToastContainerStateProps {
	    toasts?: IToastState[];
	}
	interface IToastContainerDispatchProps {
	    onDestroy?: () => void;
	    onRender?: () => void;
	    onCloseToast?: (id: string) => void;
	}
	interface IToastContainerProps extends IToastContainerOwnProps, IToastContainerStateProps, IToastContainerDispatchProps {
	}
	class ToastContainer extends React.Component<IToastContainerProps, {}> {
	    componentWillMount(): void;
	    componentWillUnmount(): void;
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	/// <reference types="react" />
	const ToastContainerConnected: React.ComponentClass<IToastContainerProps>;

}
declare module ReactVapor {
	interface IUserFeedbackProps {
	    feedbackText: string;
	    state: string;
	    extraClasses?: string[];
	    displayOnShow?: string;
	}
	interface IUserFeedbackStyle {
	    classes: string;
	}
	const UserFeedbackState: {
	    VALID: string;
	    WARNING: string;
	    ERROR: string;
	};
	const TextColorClass: {
	    default: string;
	    error: string;
	};
	class UserFeedback extends React.Component<IUserFeedbackProps, any> {
	    render(): JSX.Element;
	}

}
declare module ReactVapor {
	const version: string;

}
declare module ReactVapor {
	const divTemplateClasses: {
	    checkbox1: string;
	    checkbox2: string;
	    checkbox3: string;
	    checkbox4: string;
	};
	const divTemplateForMultipleCheckbox: string;

}
declare module ReactVapor {
    const SVG: (icon: string, classes?: string, spanClasses?: string) => string;
    const svgFromName: (icon: string, classes?: string, spanClasses?: string, title?: string) => string;
    const svg: any;
    const version: string;
}

declare module ReactVapor {
    
}
declare module ReactVapor {
    type ReactProps = any;

    type _DragSourceTypePrimitives = string | symbol;
    type DragSourceType = _DragSourceTypePrimitives | ((props: ReactProps) => _DragSourceTypePrimitives);

    type _DropTargetTypesPrimitives = string | symbol | Array<string | symbol>;
    type DropTargetTypes = _DropTargetTypesPrimitives | ((props: ReactProps) => _DropTargetTypesPrimitives);

    interface IDragSource {
        beginDrag: (props: ReactProps, monitor: DragSourceMonitor, component: React.ReactComponent) => any;
        endDrag?: (props: ReactProps, monitor: DragSourceMonitor, component?: React.ReactComponent) => void;
        canDrag?: (props: ReactProps, monitor: DragSourceMonitor) => boolean;
        isDragging?: (props: ReactProps, monitor: DragSourceMonitor) => boolean;
    }

    interface IDropTarget {
        drop?: (props: ReactProps, monitor: DropTargetMonitor, component: React.ReactComponent) => any;
        hover?: (props: ReactProps, monitor: DropTarget, component?: React.ReactComponent) => void;
        canDrop?: (props: ReactProps, monitor: DropTarget) => boolean;
    }

    interface IDropTargetProps {
        connectDropTarget?: any;
    }

    type IDragSourceCollect = (connect: DragSourceConnector, monitor: DragSourceMonitor) => any;
    type IDragTargetCollect = (connect: DropTargetConnector, monitor: DropTargetMonitor) => any;
    const DropTarget: (type: DropTargetTypes, spec: IDropTarget, collect: IDragTargetCollect) => (component: React.ReactComponent) => ReactClass;
    const DragSource: (type: DragSourceType, spec: IDragSource, collect: IDragSourceCollect) => (component: React.ReactComponent) => ReactClass;

    const DragDropContext: any;
}
declare module ReactVapor {
    
}

declare module ReactVapor {
    const X: any;
    
}

declare module ReactVapor {
    const X: any;
    
}
const unidiff: any;
declare module ReactVapor {
    
}declare module "react-vapor" {
	export = ReactVapor;
}